// Префиксная форма инкремента и постфиксная форма

let a = 1, b = 1;

alert( ++a ); // 2, префиксная форма возвращает новое значение
alert( b++ ); // 1, постфиксная форма возвращает старое значение

alert( a ); // 2, значение увеличено один раз
alert( b ); // 2, значение увеличено один раз

// Преобразование типов

"" + 1 + 0 = "10" // (1)
"" - 1 + 0 = -1 // (2)
true + false = 1
6 / "3" = 2
"2" * "3" = 6
4 + 5 + "px" = "9px"
"$" + 4 + 5 = "$45"
"4" - 2 = 2
"4px" - 2 = NaN
"  -9  " + 5 = "  -9  5" // (3)
"  -9  " - 5 = -14 // (4)
null + 1 = 1 // (5)
undefined + 1 = NaN // (6)
" \t \n" - 2 = -2 // (7)

/* Ниже приведён код, который запрашивает у пользователя два числа и показывает их сумму.
Он работает неправильно. Код в примере выводит 12 (для значения полей по умолчанию).
В чём ошибка? Исправьте её. Результат должен быть 3. */

// let a = prompt("Первое число?", 1);
// let b = prompt("Второе число?", 2);

// alert(a + b); // 12

let a = prompt("Первое число?", 1);
let b = prompt("Второе число?", 2);

alert(+a + +b); // 3

/* Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок.
Другими словами, строки сравниваются посимвольно.
Например: */

alert( 'Я' > 'А' ); // true
alert( 'Коты' > 'Кода' ); // true
alert( 'Сонный' > 'Сон' ); // true

/* Алгоритм сравнения двух строк довольно прост:

Сначала сравниваются первые символы строк.
Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй. Сравнение завершено.
Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
Сравнение продолжается, пока не закончится одна из строк.
Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.
В примерах выше сравнение 'Я' > 'А' завершится на первом шаге, тогда как строки 'Коты' и 'Кода' будут сравниваться посимвольно:

К равна К.
о равна о.
т больше, чем д. На этом сравнение заканчивается. Первая строка больше. */

/* Приведённый выше алгоритм сравнения похож на алгоритм, используемый в словарях и телефонных книгах, но между ними есть и различия.

Например, в JavaScript имеет значение регистр символов. Заглавная буква "A" не равна строчной "a". Какая же из них больше? Строчная "a". Почему? 
Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript (Unicode). 
Мы ещё поговорим о внутреннем представлении строк и его влиянии в главе Строки. */

/* Забавное следствие
Возможна следующая ситуация:

Два значения равны.
Одно из них true как логическое значение, другое – false.
Например: 

let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true! 

С точки зрения JavaScript, результат ожидаем. Равенство преобразует значения, используя числовое преобразование, поэтому "0" становится 0. 
В то время как явное преобразование с помощью Boolean использует другой набор правил.

*/

// Операторы сравнения

// Каким будет результат этих выражений?

5 > 4 // true
"ананас" > "яблоко" // false // Посимвольное, лексиграфическое сравнение
"2" > "12" // true // Посимвольное, лексиграфическое сравнение
undefined == null // true // Специальный случай. Равны друг другу только при нестрогом сравнении.
undefined === null // false
null == "\n0\n" // false // В нестрогом сравнении null равен только undefined
null === +"\n0\n" // false // Сторогое сравнение разных типов данных

// Выведется ли alert?

if ("0") {
   alert( 'Привет' );
}

// Да, выведется.
// Любая строка, кроме пустой (а строка "0" – не пустая), в логическом контексте становится true.
// Можно запустить и проверить:

/* Используя конструкцию if..else, напишите код, который будет спрашивать: „Какое «официальное» название JavaScript?“
Если пользователь вводит «ECMAScript», то показать: «Верно!», в противном случае – отобразить: «Не знаете? ECMAScript!» */

const languageName = prompt('Какое официальное название JavaScript?' 'Livescript')

if (languageName.toLowerCase() === 'ecmascript') {
   alert('Верно!')
} else {
   alert('Не знаете? ECMAScript!')
}

/* Используя конструкцию if..else, напишите код, который получает число через prompt, а затем выводит в alert:

1, если значение больше нуля,
-1, если значение меньше нуля,
0, если значение равно нулю.

Предполагается, что пользователь вводит только числа. */

const enteredValue = prompt('Введите число', '')

if (typeof +enteredValue === 'number') {
   if (enteredValue > 0) {
      alert(1)
   } else if (enteredValue < 0) {
      alert(-1)
   } else {
      alert(0)
   }
} else {
   alert('Не является числом!')
}

// Перепишите конструкцию if с использованием условного оператора '?':

// let result;

// if (a + b < 4) {
//   result = 'Мало';
// } else {
//   result = 'Много';
// }

let a = 1, b = 2, result
result = (a + b < 4) ? 'Мало' : 'Много'

alert(result)

// Перепишите if..else с использованием нескольких операторов '?'.
// Для читаемости рекомендуется разбить код на несколько строк.

let message;

message = (login == 'Сотрудник') ?
  'Привет' :
   (login == 'Директор') ?
   'Здравствуйте' :
   (login == '') ?
   'Нет логина' :
   ''

/* 
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
*/

const log = console.log

log(1)

/*
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
*/

let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'The time is 12:30' );
}

// Если первый операнд истинный,
// И возвращает второй:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

/* 

При нескольких подряд операторах И:

result = value1 && value2 && value3;
Оператор && выполняет следующие действия:

Вычисляет операнды слева направо.
Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
Если все операнды были истинными, возвращается последний.
Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.

Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое ложное значение, а ИЛИ –  первое истинное.

Примеры:

*/

// Если первый операнд ложный,
// И возвращает его. Второй операнд игнорируется
alert( null && 5 ); // null
alert( 0 && "no matter what" ); // 0

// Можно передать несколько значений подряд. В таком случае возвратится первое «ложное» значение, на котором остановились вычисления.

alert( 1 && 2 && null && 3 ); // null

// Когда все значения верны, возвращается последнее

alert( 1 && 2 && 3 ); // 3

/* 
Приоритет оператора && больше, чем у ||
Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.

Таким образом, код a && b || c && d по существу такой же, как если бы выражения && были в круглых скобках: (a && b) || (c && d).
*/

// К примеру:

let x = 1;

(x > 0) && alert( 'Greater than zero!' );

// Действие в правой части && выполнится только в том случае, если до него дойдут вычисления. То есть, alert сработает, если в левой части (x > 0) будет true.

// ДВОЙНОЕ !! (НЕ) ИСПОЛЬЗУЮТ ДЛЯ ПРЕОБРАЗОВАНИЯ ЗНАЧЕНИЙ К ЛОГИЧЕСКОМУ ТИПУ

alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false

alert( !!"non-empty string" ); // true
alert( !!null ); // false

// Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.

// Что выведет код ниже?

alert( null || 2 && 3 || 4 );

// Ответ: 3.
// alert( null || 2 && 3 || 4 );

// Приоритет оператора && выше, чем ||, поэтому он выполнится первым.

// Результат 2 && 3 = 3, поэтому выражение приобретает вид:

// null || 3 || 4
// Теперь результатом является первое истинное значение: 3.

/* Напишите условие if для проверки, что значение переменной age НЕ находится в диапазоне 14 и 90 включительно.
Напишите два варианта: первый с использованием оператора НЕ !, второй – без этого оператора. */

/* 

Какие из перечисленных ниже alert выполнятся?

Какие конкретно значения будут результатами выражений в условиях if(...)?

if (-1 || 0) alert( 'first' );
if (-1 && 0) alert( 'second' );
if (null || -1 && 1) alert( 'third' );

Ответ: первое и третье выполнятся.

Подробности:

// Выполнится.
// Результат -1 || 0 = -1, в логическом контексте true
if (-1 || 0) alert( 'first' );

// Не выполнится
// -1 && 0 = 0,  в логическом контексте false
if (-1 && 0) alert( 'second' );

// Выполнится
// оператор && имеет больший приоритет, чем ||
// так что -1 && 1 выполнится раньше
// вычисления: null || -1 && 1  ->  null || 1  ->  1
if (null || -1 && 1) alert( 'third' );

*/

/* 

const enteredLogin = prompt()

if (enteredLogin === 'админ') {
  const enteredPassword = prompt()

  if (enteredPassword === 'я главный') {
    alert('Здравствуйте!')
  } else if (enteredPassword === '' || enteredPassword === null) {
    alert('Отменено')
  } else {
    alert('Неверный пароль')
  }

} else if (enteredLogin === '' || enteredLogin === null) {
  alert('Отменено')
} else {
  alert('Я вас не знаю')  
} 

*/

// Оператор нулевого слияния (??)

/* 

Оператор нулевого слияния представляет собой два вопросительных знака ??.
Так как он обрабатывает null и undefined одинаковым образом, то для этой статьи мы введём специальный термин. Для краткости будем говорить, что значение «определено», если оно не равняется ни null, ни undefined.

Результат выражения a ?? b будет следующим:
если a определено, то a,
если a не определено, то b. 

*/

/* 

Иначе говоря, оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.
Оператор нулевого слияния не является чем-то принципиально новым. Это всего лишь удобный синтаксис, как из двух значений получить одно, которое «определено».
Вот как можно переписать выражение result = a ?? b, используя уже знакомые нам операторы:

// result = a ?? b // НОВЫЙ СИНТАКСИС

// result = (a !== null && a !== undefined) ? a : b;

*/

/*

Как правило, оператор ?? нужен для того, чтобы задать значение по умолчанию для потенциально не с переменной.
Например, здесь мы отобразим user, если её значение не null/undefined, в противном случае Аноним: */

// let user;
// alert(user ?? "Аноним"); // Аноним (user не существует)

// А вот пример, когда user присвоено значение:

// let user = "Иван";
// alert(user ?? "Аноним"); // Иван (user существует)

/* 

Кроме этого, можно записать последовательность из операторов ??, чтобы получить первое значение из списка, которое не является null/undefined.
Допустим, у нас есть данные пользователя в переменных firstName, lastName или nickName. Все они могут не существовать, если пользователь решил не вводить соответствующие значение.
Мы хотели бы отобразить имя пользователя, используя одну из этих переменных, или показать «Аноним», если все они null/undefined.
Для этого воспользуемся оператором ??: 

*/

let firstName = null;
let lastName = null;
let nickName = "Суперкодер";

// показывает первое значение, которое определено:
alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер

/* 

Исторически сложилось так, что оператор ИЛИ || появился первым. Он существует с самого начала в JavaScript, поэтому разработчики долгое время использовали его для таких целей.
С другой стороны, сравнительно недавно в язык был добавлен оператор нулевого слияния ?? – как раз потому, что многие были недовольны оператором ||.
Важное различие между ними заключается в том, что:

|| возвращает первое истинное значение.
?? возвращает первое определённое значение.

Проще говоря, оператор || не различает false, 0, пустую строку "" и null/undefined. Для него они все одинаковы, т.е. являются ложными значениями. Если первым аргументом для оператора || будет любое из перечисленных значений, то в качестве результата мы получим второй аргумент.

Однако на практике часто требуется использовать значение по умолчанию только тогда, когда переменная является null/undefined. Ведь именно тогда значение действительно неизвестно/не определено.

Рассмотрим следующий пример:

let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
height || 100 проверяет height на ложное значение, оно равно 0, да, ложное.
поэтому результатом || является второй аргумент, т.е. 100.
height ?? 100 проверяет, что переменная height содержит null/undefined, а поскольку это не так,
то результатом является сама переменная height, т.е. 0.
На практике нулевая высота часто является вполне нормальным значением, которое не следует заменять значением по умолчанию. Таким образом, ?? здесь как раз работает так, как нужно.

*/

/*

Использование ?? вместе с && или ||
По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с && и ||, если приоритет явно не указан при помощи круглых скобок.

Выполнение следующего кода приведёт к синтаксической ошибке:

let x = 1 && 2 ?? 3; // Синтаксическая ошибка
Это, безусловно спорное, ограничение было добавлено в спецификацию языка с целью избежать программные ошибки, когда люди начнут переходить с || на ??.

Используйте скобки, чтобы обойти это ограничение:

let x = (1 && 2) ?? 3; // Работает без ошибок

alert(x); // 2

*/

// Цикл while имеет следующий синтаксис:

// while (condition) {
//   // код
//   // также называемый "телом цикла"
// }

// Код из тела цикла выполняется, пока условие condition истинно.
// Например, цикл ниже выводит i, пока i < 3:

let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert(i);
  i++;
}

/* 

Одно выполнение тела цикла по-научному называется итерация. Цикл в примере выше совершает три итерации.
Если бы строка i++ отсутствовала в примере выше, то цикл бы повторялся (в теории) вечно. На практике, конечно, браузер не позволит такому случиться, он предоставит пользователю возможность остановить «подвисший» скрипт, а JavaScript на стороне сервера придётся «убить» процесс.
Любое выражение или переменная может быть условием цикла, а не только сравнение: условие while вычисляется и преобразуется в логическое значение.
Например, while (i) – более краткий вариант while (i != 0): 

*/

let i = 3;
while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
  alert( i );
  i--;
}

// Фигурные скобки не требуются для тела цикла из одной строки
// Если тело цикла состоит лишь из одной инструкции, мы можем опустить фигурные скобки {…}:

let i = 3;
while (i) alert(i--);

// Проверку условия можно разместить под телом цикла, используя специальный синтаксис do..while:

// Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова.
// Например:

let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);

// Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось хотя бы один раз, даже если условие окажется ложным.
// На практике чаще используется форма с предусловием: while(…) {…}.

// ЦИКЛ FOR

/* Более сложный, но при этом самый распространённый цикл — цикл for. Выглядит он так: */

for (начало; условие; шаг) {
   // ... тело цикла ...
}

// Давайте разберёмся, что означает каждая часть, на примере. Цикл ниже выполняет alert(i) для i от 0 до (но не включая) 3:

 for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
   alert(i);
}

// Рассмотрим конструкцию for подробней:

/* 

начало	let i = 0	Выполняется один раз при входе в цикл
условие	i < 3	Проверяется перед каждой итерацией цикла. Если оно вычислится в false, цикл остановится.
тело	alert(i)	Выполняется снова и снова, пока условие вычисляется в true.
шаг	i++	Выполняется после тела цикла на каждой итерации перед проверкой условия.

В целом, алгоритм работы цикла выглядит следующим образом:

Выполнить *начало*
→ (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
→ (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
→ (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
→ ...

В примере переменная счётчика i была объявлена прямо в цикле. Это так называемое «встроенное» объявление переменной. Такие переменные существуют только внутри цикла.
Вместо объявления новой переменной мы можем использовать уже существующую:

*/

let i = 0;

for (i = 0; i < 3; i++) { // используем существующую переменную
  alert(i); // 0, 1, 2
}

alert(i); // 3, переменная доступна, т.к. была объявлена снаружи цикла

/* 

Любая часть for может быть пропущена.
Для примера, мы можем пропустить начало если нам ничего не нужно делать перед стартом цикла.
Вот так:

*/

let i = 0; // мы уже имеем объявленную i с присвоенным значением

for (; i < 3; i++) { // нет необходимости в "начале"
  alert( i ); // 0, 1, 2
}

// Можно убрать и шаг 

let i = 0;

for (; i < 3;) {
  alert( i++ );
}

// Это сделает цикл аналогичным while (i < 3).
// А можно и вообще убрать всё, получив бесконечный цикл: 

for (;;) {
   // будет выполняться вечно
 }

// При этом сами точки с запятой ; обязательно должны присутствовать, иначе будет ошибка синтаксиса.

/* Обычно цикл завершается при вычислении условия в false.
Но мы можем выйти из цикла в любой момент с помощью специальной директивы break.
Например, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а затем – выдаёт: */

let sum = 0;

while (true) {

  let value = +prompt("Введите число", '');

  if (!value) break; // (*)

  sum += value;

}
alert( 'Сумма: ' + sum );

/* Директива break в строке (*) полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на alert.

Вообще, сочетание «бесконечный цикл + break» – отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, 
находится не в начале или конце цикла, а посередине или даже в нескольких местах его тела. */

/* 

Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).
Её используют, если понятно, что на текущем повторе цикла делать больше нечего.
Например, цикл ниже использует continue, чтобы выводить только нечётные значения:

*/

for (let i = 0; i < 10; i++) {

   // если true, пропустить оставшуюся часть тела цикла
   if (i % 2 == 0) continue;
 
   alert(i); // 1, затем 3, 5, 7, 9
 }

/* 
Для чётных значений i, директива continue прекращает выполнение тела цикла и передаёт управление на следующую итерацию for (со следующим числом). 
Таким образом alert вызывается только для нечётных значений.

Директива continue позволяет избегать вложенности
Цикл, который обрабатывает только нечётные значения, мог бы выглядеть так:

*/

for (let i = 0; i < 10; i++) {

   if (i % 2) {
     alert( i );
   }
 
 }

/* 

С технической точки зрения он полностью идентичен. Действительно, вместо continue можно просто завернуть действия в блок if.
Однако мы получили дополнительный уровень вложенности фигурных скобок. Если код внутри if более длинный, то это ухудшает читаемость, в отличие от варианта с continue. 

Нельзя использовать break/continue справа от оператора „?“
Обратите внимание, что эти синтаксические конструкции не являются выражениями и не могут быть использованы с тернарным оператором ?. В частности, использование таких директив, как break/continue, вызовет ошибку.

Например, если мы возьмём этот код:

if (i > 5) {
  alert(i);
} else {
  continue;
}
…и перепишем его, используя вопросительный знак:

(i > 5) ? alert(i) : continue; // continue здесь приведёт к ошибке
…то будет синтаксическая ошибка.

Это ещё один повод не использовать оператор вопросительного знака ? вместо if.

*/

// Какое последнее значение выведет этот код? Почему?

let i = 3;

while (i) {
  alert( i-- );
}

i = 3

// Пока i = 3, выводим i с постфиксным декрементом:
// 3, 2, 1.
// Ответ: 1

// Каждое выполнение цикла уменьшает i. Проверка while(i) остановит цикл при i = 0.
// Соответственно, будет такая последовательность шагов цикла («развернём» цикл):

// !

// Для каждого цикла запишите, какие значения он выведет. Потом сравните с ответом.
// Оба цикла выводят alert с одинаковыми значениями или нет?

// Префиксный вариант ++i:

let i = 0;
while (++i < 5) alert( i );

// пока (i + 1) < 5, выводим i

// ОТВЕТ: 1, 2, 3, 4

/* Задача демонстрирует, как постфиксные/префиксные варианты могут повлиять на результат, когда используются в сравнениях. 

Первое значение: i = 1, так как операция ++i сначала увеличит i, а потом уже произойдёт сравнение и выполнение alert.
Далее 2, 3, 4… Значения выводятся одно за другим. Для каждого значения сначала происходит увеличение, а потом – сравнение, так как ++ стоит перед переменной.
При i = 4 произойдёт увеличение i до 5, а потом сравнение while (5 < 5) – это неверно. Поэтому на этом цикл остановится, и значение 5 выведено не будет.

*/

// Постфиксный вариант i++

let i = 0;
while (i++ < 5) alert( i );

// пока i < 5 !!!, выводим i // СНАЧАЛА ПРОИСХОДИТ СРАВНЕНИЕ, А ЗАТЕМ ИНКРЕМЕНТ

// 1, 2, 3, 4, 5

/* 

let i = 0;
while (i++ < 5) alert( i );

Первое значение: i = 1. Остановимся на нём подробнее. Оператор i++ увеличивает i, возвращая старое значение, так что в сравнении i++ < 5 будет участвовать старое i = 0.
Но последующий вызов alert уже не относится к этому выражению, так что получит новый i = 1.
Далее 2, 3, 4… Для каждого значения сначала происходит сравнение, а потом – увеличение, и затем срабатывание alert.

Окончание цикла: при i = 4 произойдёт сравнение while (4 < 5) – верно, после этого сработает i++, увеличив i до 5, так что значение 5 будет выведено. Оно станет последним.
Значение i = 5 последнее, потому что на следующем шаге while (5 < 5) ложно.

*/

// Для каждого цикла запишите, какие значения он выведет. Потом сравните с ответом.
// Оба цикла выведут alert с одинаковыми значениями или нет?

// Постфиксная форма:

// for (let i = 0; i < 5; i++) alert( i );

// Префиксная форма:

// for (let i = 0; i < 5; ++i) alert( i );

// Несмотря на то, что формы инкремента разные, ответ будет одинаковым

/* 

Такой результат обусловлен алгоритмом работы for:

Выполнить единожды присваивание i = 0 перед чем-либо (начало).
Проверить условие i < 5
Если true – выполнить тело цикла alert(i), и затем i++
Увеличение i++ выполняется отдельно от проверки условия (2), значение i при этом не используется, поэтому нет никакой разницы между i++ и ++i.

*/

// При помощи цикла for выведите чётные числа от 2 до 10.

for (let i = 2; i <= 10; i++) {
  if (i % 2 === 0) {
    console.log(i)
  }
}

// Перепишите код, заменив цикл for на while, без изменения поведения цикла.

for (let i = 0; i < 3; i++) {
  console.log( `number ${i}!` );
}

let i = 0;
while (i++ < 3) console.log(`number ${i}!`);

/*

Напишите цикл, который предлагает prompt ввести число, большее 100. Если посетитель ввёл другое число – попросить ввести ещё раз, и так далее.
Цикл должен спрашивать число пока либо посетитель не введёт число, большее 100, либо не нажмёт кнопку Отмена (ESC).
Предполагается, что посетитель вводит только числа. Предусматривать обработку нечисловых строк в этой задаче необязательно.

*/

for (let i = 0, enteredNumber = prompt('Введите число больше, чем 100', ''); enteredNumber <= 100; i++) {
  if (enteredNumber === null) {break}
  enteredNumber = prompt('Введите число больше, чем 100', '')
}

// Натуральное число, большее 1, называется простым, если оно ни на что не делится, кроме себя и 1.

// Другими словами, n > 1 – простое, если при его делении на любое число кроме 1 и n есть остаток.
// Например, 5 это простое число, оно не может быть разделено без остатка на 2, 3 и 4.
// Напишите код, который выводит все простые числа из интервала от 2 до n.
// Для n = 10 результат должен быть 2,3,5,7.

// P.S. Код также должен легко модифицироваться для любых других интервалов.

// for (n = 1, interval = 10; n < interval; n++) { не подходит
//   console.log(n % (n - 1) == 0)
// }

// for(var i = 2,; i < num; i++) {} // не получается
//   if (num % i === 0) console.log(false)
//   console.log(num > 1)
// }

let n = 10;

nextPrime:
for (let i = 2; i <= n; i++) { // Для всех i...

  for (let j = 2; j < i; j++) { // проверить, делится ли число..
    if (i % j == 0) continue nextPrime; // не подходит, берём следующее
  }

  alert( i ); // простое число
}

/* Конечно же, его можно оптимизировать с точки зрения производительности. Например, проверять все j не от 2 до i, а от 2 до квадратного корня из i. 
А для очень больших чисел – существуют более эффективные специализированные алгоритмы проверки простоты числа, например квадратичное решето и решето числового поля. */

// Конструкция switch имеет один или более блок case и необязательный блок default.

// Выглядит она так:

switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break] // В скобках потому что факультативный

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}

let a = 1

switch(a) {
  case 2:  // if (a === 2)
    console.log(a)
    

  case 'two':  // if (a === 'two')
    console.log(a)

  case 1:   
    console.log('Работает')

    break

  default:
    console.log(a)
    // [break] // В скобках потому что факультативный
}

/* 

Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.
Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch).
Если ни один case не совпал – выполняется (если есть) вариант default.

*/

// Пример использования switch (сработавший код выделен):

let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Маловато' );
    break;
  case 4:
    alert( 'В точку!' ); // !!!
    break;
  case 5:
    alert( 'Перебор' );
    break;
  default:
    alert( "Нет таких значений" );
}

/*

Здесь оператор switch последовательно сравнит a со всеми вариантами из case.
Сначала 3, затем – так как нет совпадения – 4. Совпадение найдено, будет выполнен этот вариант, со строки alert( 'В точку!' ) и далее, до ближайшего break, который прервёт выполнение.
Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.
Пример без break:

*/

let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Маловато' );
  case 4:
    alert( 'В точку!' ); // !!!
  case 5:
    alert( 'Перебор' ); // !!!
  default:
    alert( "Нет таких значений" ); // !!!
}

/* 

В примере выше последовательно выполнятся три alert:

alert( 'В точку!' );
alert( 'Перебор' );
alert( "Нет таких значений" ); 

Любое выражение может быть аргументом для switch/case
И switch и case допускают любое выражение в качестве аргумента.

Например:

*/

let a = "1";
let b = 0;

switch (+a) {
  case b + 1:
    alert("Выполнится, т.к. значением +a будет 1, что в точности равно b+1");
    break;

  default:
    alert("Это не выполнится");
}

// В этом примере выражение +a вычисляется в 1, что совпадает с выражением b + 1 в case, и следовательно, код в этом блоке будет выполнен.

// Группировка «case»

// Несколько вариантов case, использующих один код, можно группировать.
// Для примера, выполним один и тот же код для case 3 и case 5, сгруппировав их:

let a = 3;

switch (a) {
  case 4:
    alert('Правильно!');
    break;

  case 3: // (*) группируем оба case
  case 5:
    alert('Неправильно!');
    alert("Может вам посетить урок математики?");
    break;

  default:
    alert('Результат выглядит странновато. Честно.');
}

/* Теперь оба варианта 3 и 5 выводят одно сообщение.

Возможность группировать case – это побочный эффект того, как switch/case работает без break.
Здесь выполнение case 3 начинается со строки (*) и продолжается в case 5, потому что отсутствует break. 

ТИП ИМЕЕТ ЗНАЧЕНИЕ
Нужно отметить, что проверка на равенство всегда строгая. Значения должны быть одного типа, чтобы выполнялось равенство.

Для примера, давайте рассмотрим следующий код:

*/

let arg = prompt("Введите число?");
switch (arg) {
  case '0':
  case '1':
    alert( 'Один или ноль' );
    break;

  case '2':
    alert( 'Два' );
    break;

  case 3:
    alert( 'Никогда не выполнится!' );
    break;
  default:
    alert( 'Неизвестное значение' );
}

/* 

Для '0' и '1' выполнится первый alert.
Для '2' – второй alert.
Но для 3, результат выполнения prompt будет строка "3", которая не соответствует строгому равенству === с числом 3.
Таким образом, мы имеем «мёртвый код» в case 3! Выполнится вариант default. 

*/

// НАПИШИТЕ IF АНАЛОГИЧНЫЙ SWITCH

switch (browser) {
  case 'Edge':
    alert( "You've got the Edge!" );
    break;

  case 'Chrome':
  case 'Firefox':
  case 'Safari':
  case 'Opera':
    alert( 'Okay we support these browsers too' );
    break;

  default:
    alert( 'We hope that this page looks ok!' );
}

if (browser === 'Edge') {
  alert('You\'ve got the Edge!')
} else if (browser === 'Chrome'
    || browser === 'Firefox'
    || browser === 'Safari'
    || browser === 'Opera') {
  alert('Okay we support these browsers too')
} else {
  alert('We hope that this page looks ok!')
}

// Перепишите код с использованием одной конструкции switch:

const number = +prompt('Введите число между 0 и 3', '');

// if (number === 0) {
//   alert('Вы ввели число 0');
// }

// if (number === 1) {
//   alert('Вы ввели число 1');
// }

// if (number === 2 || number === 3) {
//   alert('Вы ввели число 2, а может и 3');
// }

switch (number) {
  case 0:
    alert('Вы ввели число 0')
  break

  case 1:
    alert('Вы ввели число 1')
  break

  case 2: 
  case 3:
    alert('Вы ввели число 2, а может и 3')
}

/* В приведённом выше примере можно было бы сказать: "функция showMessage объявляется с двумя параметрами, затем вызывается с двумя аргументами: from и "Привет"". */

/* 

Следующая функция возвращает true, если параметр age больше 18.

В ином случае она запрашивает подтверждение через confirm и возвращает его результат:

function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    // ...
    return confirm('Родители разрешили?');
  }
}

Будет ли эта функция работать как-то иначе, если убрать else?

function checkAge(age) {
  if (age > 18) {
    return true;
  }
  // ...
  return confirm('Родители разрешили?');
}

Есть ли хоть одно отличие в поведении этого варианта? 

Оба варианта функций работают одинаково, отличий нет, так как return не только возвращает значение, но и закрывает функцию, если значение было получено.
Если return не присвоено значение, он просто закрывает функцию

-----

Следующая функция возвращает true, если параметр age больше 18.

В ином случае она задаёт вопрос confirm и возвращает его результат.

Перепишите функцию, чтобы она делала то же самое, но без if, в одну строку.

Сделайте два варианта функции checkAge:

Используя оператор ?
Используя оператор ||

*/

function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('Родители разрешили?');
  }
}

const checkAge = age => age > 18 ? true : confirm('Родители разрешили?') // Слово return в стрелочных функциях можно опустить

console.log(checkAge(19))
console.log(checkAge(10))

const checkAge = age => age > 18 || confirm('Родители разрешили?')

console.log(checkAge(29))
console.log(checkAge(12))

/* 

Напишите функцию min(a,b), которая возвращает меньшее из чисел a и b.

Пример вызовов:

min(2, 5) == 2
min(3, -1) == -1
min(1, 1) == 1

*/

const min = (a, b) => a < b ? a : b

console.log(min(14, 8))
console.log(min(3, 5))
console.log(min(0, -1))

/* 

Напишите функцию pow(x,n), которая возвращает x в степени n. Иначе говоря, умножает x на себя n раз и возвращает результат.

pow(3, 2) = 3 * 3 = 9
pow(3, 3) = 3 * 3 * 3 = 27
pow(1, 100) = 1 * 1 * ...* 1 = 1
Создайте страницу, которая запрашивает x и n, а затем выводит результат pow(x,n).

Запустить демо

P.S. В этой задаче функция обязана поддерживать только натуральные значения n, т.е. целые от 1 и выше.

*/

const pow = (x, n) => {
  if (typeof x === 'number') {
    if (typeof n === 'number' && Number.isInteger(n) && n > 0) {
      return x ** n 
    } else if (typeof n !== 'number') {
      return `${n} не является степенью`
    } else {
      return `Вычисление со степенью ${n} запрещено`
    }
  } else {
    return `${x} не является числом`
  }
}

console.log(pow(6, 2))

/* В JavaScript функции – это значения, поэтому мы и обращаемся с ними, как со значениями. Код выше выведет строковое представление функции, которое является её исходным кодом.

Конечно, функция – не обычное значение, в том смысле, что мы можем вызвать его при помощи скобок: sayHi().

Но всё же это значение. Поэтому мы можем делать с ним то же самое, что и с любым другим значением.

Мы можем скопировать функцию в другую переменную: */

function sayHi() {   // (1) создаём
  alert( "Привет" );
}

let func = sayHi;    // (2) копируем

func(); // Привет    // (3) вызываем копию (работает)!
sayHi(); // Привет   //     прежняя тоже работает (почему бы нет)

/* 

Давайте подробно разберём всё, что тут произошло:

Объявление Function Declaration (1) создало функцию и присвоило её значение переменной с именем sayHi.
В строке (2) мы скопировали её значение в переменную func. Обратите внимание (ещё раз): нет круглых скобок после sayHi. Если бы они были, то выражение func = sayHi() записало бы результат вызова sayHi() в переменную func, а не саму функцию sayHi.
Теперь функция может быть вызвана с помощью обеих переменных sayHi() и func().
Заметим, что мы могли бы использовать и Function Expression для того, чтобы создать sayHi в первой строке:

*/

let sayHi = function() {
  alert( "Привет" );
};

let func = sayHi;
// ...

/* Зачем нужна точка с запятой в конце?
У вас мог возникнуть вопрос: Почему в Function Expression ставится точка с запятой ; на конце, а в Function Declaration нет:

function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
};

Ответ прост:

Нет необходимости в ; в конце блоков кода и синтаксических конструкций, которые их используют, таких как if { ... }, for { }, function f { } и т.д.
Function Expression использует внутри себя инструкции присваивания let sayHi = ...; как значение. Это не блок кода, а выражение с присваиванием. 
Таким образом, точка с запятой не относится непосредственно к Function Expression, она лишь завершает инструкцию.

-----

Рассмотрим ещё примеры функциональных выражений и передачи функции как значения.

Давайте напишем функцию ask(question, yes, no) с тремя параметрами:

question
Текст вопроса
yes
Функция, которая будет вызываться, если ответ будет «Yes»
no
Функция, которая будет вызываться, если ответ будет «No»
Наша функция должна задать вопрос question и, в зависимости от того, как ответит пользователь, вызвать yes() или no():

*/

function ask(question, yes, no) { // ОЧЕНЬ ВАЖНО
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "Вы согласны." );
}

function showCancel() {
  alert( "Вы отменили выполнение." );
}

// использование: функции showOk, showCancel передаются в качестве аргументов ask
ask("Вы согласны?", showOk, showCancel);

/* На практике подобные функции очень полезны. Основное отличие «реальной» функции ask от примера выше будет в том, что она использует более сложные способы взаимодействия 
с пользователем, чем простой вызов confirm. В браузерах такие функции обычно отображают красивые диалоговые окна. Но это уже другая история.

Аргументы функции ask ещё называют функциями-колбэками или просто колбэками.

Ключевая идея в том, что мы передаём функцию и ожидаем, что она вызовется обратно (от англ. «call back» – обратный вызов) когда-нибудь позже, если это будет необходимо. 
В нашем случае, showOk становится колбэком’ для ответа «yes», а showCancel – для ответа «no».

Мы можем переписать этот пример значительно короче, используя Function Expression:

*/

function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);

/*

Здесь функции объявляются прямо внутри вызова ask(...). У них нет имён, поэтому они называются анонимными. 
Такие функции недоступны снаружи ask (потому что они не присвоены переменным), но это как раз то, что нам нужно.
Подобный код, появившийся в нашем скрипте выглядит очень естественно, в духе JavaScript.

-----

Давайте разберём ключевые отличия Function Declaration от Function Expression.
Во-первых, синтаксис: как определить, что есть что в коде.

Function Declaration: функция объявляется отдельной конструкцией «function…» в основном потоке кода.

// Function Declaration
function sum(a, b) {
  return a + b;
}

Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае функция создаётся в правой части «выражения присваивания» =:

// Function Expression
let sum = function(a, b) {
  return a + b;
};

Более тонкое отличие состоит, в том, когда создаётся функция движком JavaScript.
Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.
После того, как поток выполнения достигнет правой части выражения присваивания let sum = function… – с этого момента 
функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ).

С Function Declaration всё иначе.
Function Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).
Другими словами, когда движок JavaScript готовится выполнять скрипт или блок кода, прежде всего он ищет в нём Function Declaration и создаёт все такие функции. 
Можно считать этот процесс «стадией инициализации».

И только после того, как все объявления Function Declaration будут обработаны, продолжится выполнение.
В результате, функции, созданные, как Function Declaration могут быть вызваны раньше своих определений.

Например, так будет работать:

*/

sayHi("Вася"); // Привет, Вася

function sayHi(name) {
  alert( `Привет, ${name}` );
}

/*

Функция sayHi была создана, когда движок JavaScript подготавливал скрипт к выполнению, и такая функция видна повсюду в этом скрипте.

…Если бы это было Function Expression, то такой код вызвал бы ошибку:

*/

sayHi("Вася"); // ошибка!

let sayHi = function(name) {  // (*) магии больше нет
  alert( `Привет, ${name}` );
};

/*

Функции, объявленные при помощи Function Expression, создаются тогда, когда выполнение доходит до них. Это случится только на строке, помеченной звёздочкой (*). Слишком поздно.
Ещё одна важная особенность Function Declaration заключается в их блочной области видимости.
В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.
Для примера давайте представим, что нам нужно создать функцию welcome() в зависимости от значения переменной age, которое мы получим во время выполнения кода. 
И затем запланируем использовать её когда-нибудь в будущем.
Такой код, использующий Function Declaration, работать не будет:

*/

let age = prompt("Сколько Вам лет?", 18);

// в зависимости от условия объявляем функцию
if (age < 18) {

  function welcome() {
    alert("Привет!");
  }

} else {

  function welcome() {
    alert("Здравствуйте!");
  }

}

// ...не работает
welcome(); // Error: welcome is not defined

// Это произошло, так как объявление Function Declaration видимо только внутри блока кода, в котором располагается.
// Вот ещё один пример:

let age = 16; // присвоим для примера 16

if (age < 18) {
  welcome();               // \   (выполнится)
                           //  |
  function welcome() {     //  |
    alert("Привет!");      //  |  Function Declaration доступно
  }                        //  |  во всём блоке кода, в котором объявлено
                           //  |
  welcome();               // /   (выполнится)

} else {

  function welcome() {
    alert("Здравствуйте!");
  }
}

// здесь фигурная скобка закрывается,
// поэтому Function Declaration, созданные внутри блока кода выше -- недоступны отсюда.

welcome(); // Ошибка: welcome is not defined

/*

Что можно сделать, чтобы welcome была видима снаружи if?
Верным подходом будет воспользоваться функцией, объявленной при помощи Function Expression, и присвоить 
значение welcome переменной, объявленной снаружи if, что обеспечит нам нужную видимость.
Такой код работает, как ожидалось:

*/

let age = prompt("Сколько Вам лет?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Привет!");
  };

} else {

  welcome = function() {
    alert("Здравствуйте!");
  };

}

welcome(); // теперь всё в порядке

// Можно упростить этот код ещё сильнее, используя условный оператор ?:

let age = prompt("Сколько Вам лет?", 18);

let welcome = (age < 18) ?
  function() { alert("Привет!"); } :
  function() { alert("Здравствуйте!"); };

welcome(); // теперь всё в порядке

/*

Когда использовать Function Declaration, а когда Function Expression?
Как правило, если нам понадобилась функция, в первую очередь нужно рассматривать синтаксис Function Declaration, который мы использовали до этого. 
Он даёт нам больше свободы в том, как мы можем организовывать код. Функции, объявленные таким образом, можно вызывать до их объявления.

Также функции вида function f(…) {…} чуть более заметны в коде, чем let f = function(…) {…}. Function Declaration легче «ловятся глазами».

…Но если Function Declaration нам не подходит по какой-то причине (мы рассмотрели это в примере выше), то можно использовать объявление при помощи Function Expression.

*/

/*

Итого
Функции – это значения. Они могут быть присвоены, скопированы или объявлены в любом месте кода.
Если функция объявлена как отдельная инструкция в основном потоке кода, то это Function Declaration.
Если функция была создана как часть выражения, то считается, что эта функция объявлена при помощи Function Expression.
Function Declaration обрабатываются перед выполнением блока кода. Они видны во всём блоке.
Функции, объявленные при помощи Function Expression, создаются, только когда поток выполнения достигает их.
В большинстве случаев, когда нам нужно создать функцию, предпочтительно использовать Function Declaration, т.к. функция будет видима до своего объявления в коде. 
Это позволяет более гибко организовывать код и улучшает его читаемость.

Таким образом, мы должны прибегать к объявлению функций при помощи Function Expression в случае, когда синтаксис Function Declaration не подходит для нашей задачи. 
Мы рассмотрели несколько таких примеров в этой главе, и рассмотрим их ещё больше в будущем.

*/

function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);

// -----

const ask = (question, yes, no) => {
  confirm(question) ? yes() : no()
}

ask(
  "Вы согласны?",
  () => alert("Вы согласились."),
  () => alert("Вы отменили выполнение.") 
)

// Плохой стиль
// важность: 4
// Какие недостатки вы видите в стиле написания кода этого примера?

function pow(x,n)
{
  let result=1;
  for(let i=0;i<n;i++) {result*=x;}
  return result;
}

let x=prompt("x?",''), n=prompt("n?",'')
if (n<=0)
{
  alert(`Степень ${n} не поддерживается, введите целую степень, большую 0`);
}
else
{
  alert(pow(x,n))
}

/// ИСПРАВЛЕНИЕ

function pow(x, n) { // Перечисление аргументов через пробел, открывающая скобка функции должна быть на той же строке, где и объявляется
  let result = 1 // Пробелы между операндами во время присваивания, отступ после переменной

  for (let i = 0; i < n; i++) { // Пробел после начала цикла, пробелы между операндами и между аргументами, скобки на разных строках
    result *= x; // Пробел между операндами
  }
  return result
}

let x = prompt('x?', '') // Пробелы между операндами, пробелы между аргументами, единый стиль кавычек, объявление переменных на разных строках
let n = prompt('n?', '') 
// Отступ после переменной

if (n <= 0) { // Открывающая скобка там же, где объявляется инструкция
  alert(`Степень ${n} не поддерживается, введите целую степень, большую 0`)
} else { // else не переносится
  alert( pow(x, n) ) // Пробелы между аргументами, пробелы вокруг вложенной инструкции
}

/* Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. Например, имя свойства может храниться в переменной: */

let key = "likes birds";

// то же самое, что и user["likes birds"] = true;
user[key] = true;

// Здесь переменная key может быть вычислена во время выполнения кода или зависеть от пользовательского ввода.
// После этого мы используем её для доступа к свойству. Это даёт нам большую гибкость.

let user = {
  name: "John",
  age: 30
};

let key = prompt("Что вы хотите узнать о пользователе?", "name");

// доступ к свойству через переменную
alert( user[key] ); // John (если ввели "name")

// Запись «через точку» такого не позволяет

/* 

В реальном коде часто нам необходимо использовать существующие переменные как значения для свойств с тем же именем.
Например:

*/

function makeUser(name, age) {
  return {
    name: name,
    age: age
    // ...другие свойства
  };
}

let user = makeUser("John", 30);
alert(user.name); // John

/* 

В примере выше название свойств name и age совпадают с названиями переменных, которые мы подставляем в качестве значений этих свойств. 
Такой подход настолько распространён, что существуют специальные короткие свойства для упрощения этой записи.

Вместо name:name мы можем написать просто name: 

*/

function makeUser(name, age) {
  return {
    name, // то же самое, что и name: name
    age   // то же самое, что и age: age
    // ...
  };
}

// Мы можем использовать как обычные свойства, так и короткие в одном и том же объекте:

let user = {
  name,  // тоже самое, что и name:name
  age: 30
};

/* 

Как мы уже знаем, имя переменной не может совпадать с зарезервированными словами, такими как «for», «let», «return» и т.д.
Но для свойств объекта такого ограничения нет:

*/

// эти имена свойств допустимы
let obj = {
  for: 1,
  let: 2,
  return: 3
};

alert( obj.for + obj.let + obj.return );  // 6

/*

Иными словами, нет никаких ограничений к именам свойств. Они могут быть в виде строк или символов (специальный тип для идентификаторов, который будет рассмотрен позже).
Все другие типы данных будут автоматически преобразованы к строке.
Например, если использовать число 0 в качестве ключа, то оно превратится в строку "0":

*/

let obj = {
  0: "Тест" // то же самое что и "0": "Тест"
};

// обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
alert( obj["0"] ); // Тест
alert( obj[0] ); // Тест (то же свойство)

/*

В отличие от многих других языков, особенность JavaScript-объектов в том, что можно получить доступ к любому свойству. Даже если свойства не существует – ошибки не будет!
При обращении к свойству, которого нет, возвращается undefined. Это позволяет просто проверить существование свойства:

*/

let user = {};
alert( user.noSuchProperty === undefined ); // true означает "свойства нет"

// Также существует специальный оператор "in" для проверки существования свойства в объекте.
// Синтаксис оператора:

'key' in object

// Пример

let user = { name: "John", age: 30 };

alert( "age" in user ); // true, user.age существует /// !!!!!
alert( "blabla" in user ); // false, user.blabla не существует /// !!!!!

// Обратите внимание, что слева от оператора in должно быть имя свойства. Обычно это строка в кавычках.
// Если мы опускаем кавычки, это значит, что мы указываем переменную, в которой находится имя свойства. Например:

let user = { age: 30 };

let key = "age"; /// !!!!!
alert( key in user ); // true, имя свойства было взято из переменной key

// Для перебора всех свойств объекта используется цикл for..in. Этот цикл отличается от изученного ранее цикла for(;;).
// Синтаксис:

for (key in object) {
  // тело цикла выполняется для каждого свойства объекта
}

let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

// К примеру, давайте выведем все свойства объекта user:

for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}

/*

Упорядочены ли свойства объекта? Другими словами, если мы будем в цикле перебирать все свойства объекта, получим ли мы их в том же порядке, в котором мы их добавляли? 
Можем ли мы на это рассчитывать?
Короткий ответ: свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания. 
Разберёмся подробнее.
В качестве примера рассмотрим объект с телефонными кодами:

*/

let codes = {
  "49": "Германия",
  "41": "Швейцария",
  "44": "Великобритания",
  // ..,
  "1": "США"
};

for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}

/* 

Если мы делаем сайт для немецкой аудитории, то, вероятно, мы хотим, чтобы код 49 был первым.

Но если мы запустим код, мы увидим совершенно другую картину:

США (1) идёт первым
затем Швейцария (41) и так далее.
Телефонные коды идут в порядке возрастания, потому что они являются целыми числами: 1, 41, 44, 49.

Целочисленные свойства? Это что?
Термин «целочисленное свойство» означает строку, которая может быть преобразована в целое число и обратно без изменений.

То есть, "49" – это целочисленное имя свойства, потому что если его преобразовать в целое число, а затем обратно в строку, то оно не изменится. 
А вот свойства "+49" или "1.2" таковыми не являются:

*/

// Math.trunc - встроенная функция, которая удаляет десятичную часть
alert( String(Math.trunc(Number("49"))) ); // "49", то же самое ⇒ свойство целочисленное
alert( String(Math.trunc(Number("+49"))) ); // "49", не то же самое, что "+49" ⇒ свойство не целочисленное
alert( String(Math.trunc(Number("1.2"))) ); // "1", не то же самое, что "1.2" ⇒ свойство не целочисленное

// …С другой стороны, если ключи не целочисленные, то они перебираются в порядке создания, например:

let user = {
  name: "John",
  surname: "Smith"
};
user.age = 25; // добавим ещё одно свойство

// не целочисленные свойства перечислены в порядке создания
for (let prop in user) {
  alert( prop ); // name, surname, age
}

/*

Таким образом, чтобы решить нашу проблему с телефонными кодами, мы можем схитрить, сделав коды не целочисленными свойствами. 
Добавления знака "+" перед каждым кодом будет достаточно.

Пример:

*/

let codes = {
  "+49": "Германия",
  "+41": "Швейцария",
  "+44": "Великобритания",
  // ..,
  "+1": "США"
};

for (let code in codes) {
  alert( +code ); // 49, 41, 44, 1
}

/*

Объекты – это ассоциативные массивы с рядом дополнительных возможностей.

Они хранят свойства (пары ключ-значение), где:

Ключи свойств должны быть строками или символами (обычно строками).
Значения могут быть любого типа.
Чтобы получить доступ к свойству, мы можем использовать:

Запись через точку: obj.property.
Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].
Дополнительные операторы:

Удаление свойства: delete obj.prop.
Проверка существования свойства: "key" in obj.
Перебор свойств объекта: цикл for for (let key in obj).
То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object.

В JavaScript есть много других типов объектов:

Array для хранения упорядоченных коллекций данных,
Date для хранения информации о дате и времени,
Error для хранения информации об ошибке.
… и так далее.
У них есть свои особенности, которые мы изучим позже. Иногда люди говорят что-то вроде «тип данных Array» или «тип данных Date»,
но формально они не являются отдельными типами, а относятся к типу данных Object. Они лишь расширяют его различными способами.

Объекты в JavaScript очень мощные. Здесь мы только немного углубились в действительно огромную тему. 
Мы будем плотно работать с объектами и узнаем о них больше в следующих частях учебника.

*/

/* 

Напишите код, выполнив задание из каждого пункта отдельной строкой:

Создайте пустой объект user.
Добавьте свойство name со значением John.
Добавьте свойство surname со значением Smith.
Измените значение свойства name на Pete.
Удалите свойство name из объекта.

*/

const user = {}
user.name = 'John'
user.surname = 'Smith'
user.name = 'Pete'
delete user.name

console.log(user)

/*

Напишите функцию isEmpty(obj), которая возвращает true, если у объекта нет свойств, иначе false.
Должно работать так:

*/

function isEmpty(obj) {

  for (let key in obj) {
    let result = key in obj
  }
  
  return result
}

let schedule = {}

alert( isEmpty(schedule) ); // true

// schedule["8:30"] = "get up";

// alert( isEmpty(schedule) ); // false

// Просто в цикле перебираем свойства объекта и возвращаем false, как только встречаем свойство.

function isEmpty(obj) {

  for (let key in obj) {
    return false
  }

  return true
}

let schedule = {}

console.log( isEmpty(schedule) ); // true

schedule.code = 135345214156

console.log( isEmpty(schedule) ); // false

// Можно ли изменить объект, объявленный с помощью const? Как вы думаете?

const user = {
  name: "John"
};

// это будет работать?
user.name = "Pete"; // ДА ЭТО БУДЕТ РАБОТАТЬ

// Обращаться и редактировать своойства константы-объекта можно, но нельзя редактировать саму переменную, в которую вложен объект

/*

Объявление const защищает только саму переменную от изменений.
Другими словами, user хранит ссылку на объект. И это не может быть изменено. Но содержимое объекта менять можно.

*/

// У нас есть объект, в котором хранятся зарплаты нашей команды:

// Напишите код для суммирования всех зарплат и сохраните результат в переменной sum. Должно получиться 390.
// Если объект salaries пуст, то результат должен быть 0.

let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
}

let sum = 0

for (let key in salaries) {
  sum += salaries[key]
}

console.log(sum)

/*

Создайте функцию multiplyNumeric(obj), которая умножает все числовые свойства объекта obj на 2.

Например:

// до вызова функции
let menu = {
  width: 200,
  height: 300,
  title: "My menu"
};

multiplyNumeric(menu);

// после вызова функции
menu = {
  width: 400,
  height: 600,
  title: "My menu"
};

Обратите внимание, что multiplyNumeric не нужно ничего возвращать. Следует напрямую изменять объект.

P.S. Используйте typeof для проверки, что значение свойства числовое.

*/

let menu = {
  width: 200,
  height: 300,
  title: "My menu"
}

console.log(menu)

const multiplyNumeric = (obj, multiplier) => {

  const keysArray = Object.keys(obj)
  const valuesArray = Object.values(obj)

  for (i = 0; i < valuesArray.length; i++) {
      if (typeof valuesArray[i] === 'number') {
          valuesArray[i] *= multiplier
          obj[keysArray[i]] = valuesArray[i]
      }
  }
}

multiplyNumeric(menu, 5)
console.log(menu)

/*

Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке».
Примитивные типы: строки, числа, логические значения – присваиваются и копируются «по значению».

Например:

*/

let message = "Привет!";
let phrase = message;

// В результате мы имеем две независимые переменные, каждая из которых хранит строку "Привет!".

/* 

Объекты ведут себя иначе.
Переменная хранит не сам объект, а его «адрес в памяти», другими словами «ссылку» на него.

Проиллюстрируем это:

*/

let user = {
  name: "Иван"
};

/*

Сам объект хранится где-то в памяти. А в переменной user лежит «ссылка» на эту область памяти.
Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется.
Если мы представляем объект как ящик, то переменная – это ключ к нему. Копирование переменной дублирует ключ, но не сам ящик.

Например:

*/

let user = { name: "Иван" };

let admin = user; // копируется ссылка

// Теперь у нас есть две переменные, каждая из которых содержит ссылку на один и тот же объект:

// Мы можем использовать любую из переменных для доступа к ящику и изменения его содержимого:

let user = { name: 'Иван' };

let admin = user;

admin.name = 'Петя'; // изменено по ссылке из переменной "admin"

alert(user.name); // 'Петя', изменения видны по ссылке из переменной "user"

/*

Приведённый выше пример демонстрирует, что объект только один. Как если бы у нас был один ящик с двумя ключами и мы использовали один из них (admin), 
чтобы войти в него и что-то изменить, а затем, открыв ящик другим ключом (user), мы бы увидели эти изменения.

Операторы равенства == и строгого равенства === для объектов работают одинаково.
Два объекта равны только в том случае, если это один и тот же объект.

В примере ниже две переменные ссылаются на один и тот же объект, поэтому они равны друг другу:

*/

let a = {};
let b = a; // копирование по ссылке

alert( a == b ); // true, т.к. обе переменные ссылаются на один и тот же объект
alert( a === b ); // true

// В другом примере два разных объекта не равны, хотя оба пусты:

let a = {};
let b = {}; // два независимых объекта

alert( a == b ); // false

/*

Таким образом, при копировании переменной с объектом создаётся ещё одна ссылка на тот же самый объект.
Но что, если нам всё же нужно дублировать объект? Создать независимую копию, клон?

Это выполнимо, но немного сложно, так как в JavaScript нет встроенного метода для этого. На самом деле, такая нужда возникает редко. 
В большинстве случаев нам достаточно копирования по ссылке.
Но если мы действительно этого хотим, то нам нужно создавать новый объект и повторять структуру дублируемого объекта, перебирая его свойства и копируя их.

Например так:

*/

let user = {
  name: "Иван",
  age: 30
};

let clone = {}; // новый пустой объект

// скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}

// теперь в переменной clone находится абсолютно независимый клон объекта
clone.name = "Пётр"; // изменим в нём данные

alert( user.name ); // в оригинальном объекте значение свойства `name` осталось прежним – Иван.

// Кроме того, для этих целей мы можем использовать метод Object.assign.
// Синтаксис: Object.assign(dest, [src1, src2, src3...])

/*

Первый аргумент dest — целевой объект.
Остальные аргументы src1, ..., srcN (может быть столько, сколько нужно) являются исходными объектами
Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. То есть, свойства всех перечисленных объектов, начиная со второго, копируются в первый объект.
Возвращает объект dest.

Например, объединим несколько объектов в один:

*/

let user = { name: "Иван" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);

// теперь user = { name: "Иван", canView: true, canEdit: true }

// Если принимающий объект (user) уже имеет свойство с таким именем, оно будет перезаписано:

let user = { name: "Иван" };

Object.assign(user, { name: "Пётр" });

alert(user.name); // теперь user = { name: "Пётр" }

// Мы также можем использовать Object.assign для замены for..in на простое клонирование:

let user = {
  name: "Иван",
  age: 30
};

let clone = Object.assign({}, user);

// Этот метод скопирует все свойства объекта user в пустой объект и возвратит его.
// Вложенное клонирование

/*

До сих пор мы предполагали, что все свойства объекта user хранят примитивные значения. Но свойства могут быть ссылками на другие объекты. Что с ними делать?
Например, есть объект:

*/

let user = {
  name: "Иван",
  sizes: {
    height: 182,
    width: 50
  }
};

alert( user.sizes.height ); // 182

/*

Теперь при клонировании недостаточно просто скопировать clone.sizes = user.sizes, поскольку user.sizes – это объект, он будет скопирован по ссылке. 
А значит объекты clone и user в своих свойствах sizes будут ссылаться на один и тот же объект:

*/

let user = {
  name: "Иван",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, один и тот же объект

// user и clone обращаются к одному sizes
user.sizes.width++;       // меняем свойство в одном объекте
alert(clone.sizes.width); // 51, видим результат в другом объекте

/*

Чтобы исправить это, мы должны в цикле клонирования делать проверку, не является ли значение user[key] объектом, и если это так – скопировать и его структуру тоже. 
Это называется «глубокое клонирование». Мы можем реализовать глубокое клонирование, используя рекурсию. 
Или, чтобы не изобретать велосипед, использовать готовую реализацию — метод _.cloneDeep(obj) из JavaScript-библиотеки lodash.

ИТОГО

Объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не «значение объекта», а «ссылку» (адрес в памяти) на это значение. 
Поэтому копирование такой переменной или передача её в качестве аргумента функции приводит к копированию этой ссылки, а не самого объекта.

Все операции с использованием скопированных ссылок (например, добавление или удаление свойств) выполняются с одним и тем же объектом.

Для «простого клонирования» объекта можно использовать Object.assign. Необходимо помнить, что Object.assign не делает глубокое клонирование объекта. 
Если внутри копируемого объекта есть свойство, значение которого не является примитивом, оно будет передано по ссылке. 
Для создания «настоящей копии» (полного клона объекта) можно воспользоваться методом из сторонней JavaScript-библиотеки _.cloneDeep(obj).

*/

// ЗАМЕТКА

/*

Так клонируются объекты вместе со всеми вложениями:
const newObject = JSON.parse(JSON.stringify(object))

Сначала переводим объект в JSON, потом возвращаем его в JS

НО МЕТОДЫ JSON ОЧЕНЬ ЗАТРАТНЫ (ЛУЧШЕ НЕ ИСПОЛЬЗОВАТЬ)

*/

// СБОРКА МУСОРА

/*

Управление памятью в JavaScript выполняется автоматически и незаметно. Мы создаём примитивы, объекты, функции… Всё это занимает память.
Но что происходит, когда что-то больше не нужно? Как JavaScript понимает, что пора очищать память?

Основной концепцией управления памятью в JavaScript является принцип достижимости.

Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти.

Существует базовое множество достижимых значений, которые не могут быть удалены.

Например:

Локальные переменные и параметры текущей функции.
Переменные и параметры других функций в текущей цепочке вложенных вызовов.
Глобальные переменные.
(некоторые другие внутренние значения)
Эти значения мы будем называть корнями.

Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.

Например, если в локальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, то этот объект считается достижимым. 
И те, на которые он ссылается, тоже достижимы. Далее вы познакомитесь с подробными примерами на эту тему.

В интерпретаторе JavaScript есть фоновый процесс, который называется сборщик мусора. Он следит за всеми объектами и удаляет те, которые стали недостижимы.

Вот самый простой пример:

*/

// в user находится ссылка на объект
let user = {
  name: "John"
};

/*

Глобальная переменная user ссылается на объект {name: "John"} (мы будем называть его просто «John»). 
В свойстве "name" объекта John хранится примитив, поэтому оно нарисовано внутри объекта.
Если перезаписать значение user, то ссылка потеряется:

*/

user = null;

// Теперь объект John становится недостижимым. К нему нет доступа, на него нет ссылок. Сборщик мусора удалит эти данные и освободит память.

// ДВЕ ССЫЛКИ

// Представим, что мы скопировали ссылку из user в admin:

// в user находится ссылка на объект

let user = {
  name: "John"
};

let admin = user;

// Теперь, если мы сделаем то же самое:

user = null;

/*

…то объект John всё ещё достижим через глобальную переменную admin, поэтому он находится в памяти. Если бы мы также перезаписали admin, то John был бы удалён.

*/

// Взаимосвязанные объекты
// Теперь более сложный пример. Семья:

function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
});

/*

Функция marry «женит» два объекта, давая им ссылки друг на друга, и возвращает новый объект, содержащий ссылки на два предыдущих.
В результате получаем такую структуру памяти:

*/

// На данный момент все объекты достижимы.
// Теперь удалим две ссылки:

delete family.father;
delete family.mother.husband;

// Недостаточно удалить только одну из этих ссылок, потому что все объекты останутся достижимыми.
// Но если мы удалим обе, то увидим, что у объекта John больше нет входящих ссылок:

/*

Исходящие ссылки не имеют значения. Только входящие ссылки могут сделать объект достижимым. 
Объект John теперь недостижим и будет удалён из памяти со всеми своими данными, которые также стали недоступны.

*/

// Вполне возможна ситуация, при которой целый «остров» связанных объектов может стать недостижимым и удалиться из памяти.
// Возьмём объект family из примера выше. А затем:

family = null;

// Структура в памяти теперь станет такой:

/*

Основной алгоритм сборки мусора – «алгоритм пометок» (англ. «mark-and-sweep»).

Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:

Сборщик мусора «помечает» (запоминает) все корневые объекты.
Затем он идёт по их ссылкам и помечает все найденные объекты.
Затем он идёт по ссылкам помеченных объектов и помечает объекты, на которые есть ссылка от них. Все объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
…И так далее, пока не будут посещены все ссылки (достижимые от корней).
Все непомеченные объекты удаляются.

*/

// Методы объекта, "this"

// Объекты обычно создаются, чтобы представлять сущности реального мира, будь то пользователи, заказы и так далее:

// Объект пользователя
let user = {
  name: "Джон",
  age: 30
};

// И так же, как и в реальном мире, пользователь может совершать действия: 
// выбирать что-то из корзины покупок, авторизовываться, выходить из системы, оплачивать и т.п.
// Такие действия в JavaScript представлены свойствами-функциями объекта.

// Для начала давайте научим нашего пользователя user здороваться:

let user = {
  name: "Джон",
  age: 30
};

user.sayHi = function() {
  alert("Привет!");
};

user.sayHi(); // Привет!

/*

Здесь мы просто использовали Function Expression (функциональное выражение), чтобы создать функцию для приветствия, и присвоили её свойству user.sayHi нашего объекта.
Затем мы вызвали её. Теперь пользователь может говорить!

Функцию, которая является свойством объекта, называют методом этого объекта.
Итак, мы получили метод sayHi объекта user.

Конечно, мы могли бы заранее объявить функцию и использовать её в качестве метода, примерно так:

*/

let user = {
  // ...
};

// сначала объявляем
function sayHi() {
  alert("Привет!");
}

// затем добавляем в качестве метода
user.sayHi = sayHi;

user.sayHi(); // Привет!

// Объектно-ориентированное программирование

/*

Когда мы пишем наш код, используя объекты для представления сущностей реального мира, – это называется объектно-ориентированное программирование или сокращённо: «ООП».

ООП является большой предметной областью и интересной наукой само по себе. Как выбрать правильные сущности? Как организовать взаимодействие между ними? 
Это – создание архитектуры, и есть хорошие книги по этой теме, такие как «Приёмы объектно-ориентированного проектирования. 
Паттерны проектирования» авторов Эрих Гамма, Ричард Хелм, Ральф Джонсон, Джон Влиссидес или «Объектно-ориентированный анализ и 
проектирование с примерами приложений» Гради Буча, а также ещё множество других книг.

*/

// Существует более короткий синтаксис для методов в литерале объекта:

// эти объекты делают одно и то же (одинаковые методы)

user = {
  sayHi: function() {
    alert("Привет");
  }
};

// сокращённая запись выглядит лучше, не так ли?
user = {
  sayHi() { // то же самое, что и "sayHi: function()"
    alert("Привет");
  }
};

/*

Как было показано, мы можем пропустить ключевое слово "function" и просто написать sayHi().

Нужно отметить, что эти две записи не полностью эквивалентны. Есть тонкие различия, связанные с наследованием объектов (что будет рассмотрено позже),
но на данном этапе изучения это неважно. В большинстве случаев сокращённый синтаксис предпочтителен.


Как правило, методу объекта необходим доступ к информации, которая хранится в объекте, чтобы выполнить с ней какие-либо действия (в соответствии с назначением метода).
Например, коду внутри user.sayHi() может понадобиться имя пользователя, которое хранится в объекте user.

Для доступа к информации внутри объекта метод может использовать ключевое слово this.
Значение this – это объект «перед точкой», который использовался для вызова метода.

Например:

*/

let user = {
  name: "Джон",
  age: 30,

  sayHi() {
    // this - это "текущий объект"
    alert(this.name);
  }

};

user.sayHi(); // Джон

// Технически также возможно получить доступ к объекту без ключевого слова this, ссылаясь на него через внешнюю переменную (в которой хранится ссылка на этот объект):

let user = {
  name: "Джон",
  age: 30,

  sayHi() {
    alert(user.name); // используем переменную "user" вместо ключевого слова "this"
  }

};

/*

…Но такой код будет ненадёжным. Если мы решим скопировать ссылку на объект user в другую переменную, например, admin = user, 
и перезапишем переменную user чем-то другим, тогда будет осуществлён доступ к неправильному объекту при вызове метода из admin.

Это показано ниже:

*/

let user = {
  name: "Джон",
  age: 30,

  sayHi() {
    alert( user.name ); // приведёт к ошибке
  }

};


let admin = user;
user = null; // обнулим переменную для наглядности, теперь она не хранит ссылку на объект.

admin.sayHi(); // Ошибка! Внутри sayHi() используется user, которая больше не ссылается на объект!

// Если мы используем this.name вместо user.name внутри alert, тогда этот код будет работать.

// В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования. Оно может использоваться в любой функции.
// В этом коде нет синтаксической ошибки:

function sayHi() {
  alert( this.name );
}

/* 

Значение this вычисляется во время выполнения кода и зависит от контекста.
Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение «this» при вызовах:

*/

let user = { name: "Джон" };
let admin = { name: "Админ" };

function sayHi() {
  alert( this.name );
}

// используем одну и ту же функцию в двух объектах
user.f = sayHi;
admin.f = sayHi;

// вызовы функции, приведённые ниже, имеют разное значение this
// "this" внутри функции является ссылкой на объект, который указан "перед точкой"
user.f(); // Джон  (this == user)
admin.f(); // Админ  (this == admin)

admin['f'](); // Админ (неважен способ доступа к методу - через точку или квадратные скобки)

// Правило простое: при вызове obj.f() значение this внутри f равно obj. Так что, в приведённом примере это user или admin.

// Вызов без объекта: this == undefined
// Мы даже можем вызвать функцию вовсе без использования объекта:

function sayHi() {
  alert(this);
}

sayHi(); // undefined

/*

В строгом режиме ("use strict") в таком коде значением this будет являться undefined. Если мы попытаемся получить доступ к name, используя this.name – это вызовет ошибку.
В нестрогом режиме значением this в таком случае будет глобальный объект (window для браузера, мы вернёмся к этому позже в главе Глобальный объект). 
Это – исторически сложившееся поведение this, которое исправляется использованием строгого режима ("use strict").
Обычно подобный вызов является ошибкой программирования. Если внутри функции используется this, тогда ожидается, что она будет вызываться в контексте какого-либо объекта.

*/

// Внутренняя реализация: Ссылочный тип

/*

Продвинутая возможность языка
Этот раздел объясняет сложную тему, чтобы лучше понимать некоторые запутанные случаи.

Если вы хотите продвигаться быстрее, его можно пропустить или отложить.

*/

// Некоторые хитрые способы вызова метода приводят к потере значения this, например:

let user = {
  name: "Джон",
  hi() { alert(this.name); },
  bye() { alert("Пока"); }
};

user.hi(); // Джон (простой вызов метода работает хорошо)

// теперь давайте попробуем вызывать user.hi или user.bye
// в зависимости от имени пользователя user.name
(user.name == "Джон" ? user.hi : user.bye)(); // Ошибка!

// В последней строчке кода используется условный оператор ?, который определяет, какой будет вызван метод (user.hi или user.bye) 
// в зависимости от выполнения условия. В данном случае будет выбран user.hi.

/*

Затем метод тут же вызывается с помощью скобок (). Но вызов не работает как положено!

Вы можете видеть, что при вызове будет ошибка, потому что значением "this" внутри функции становится undefined (полагаем, что у нас строгий режим).
Так работает (доступ к методу объекта через точку):

*/

user.hi();

// Так уже не работает (вызываемый метод вычисляется):

(user.name == "Джон" ? user.hi : user.bye)(); // Ошибка!

/*

Почему? Если мы хотим понять, почему так происходит, давайте разберёмся (заглянем под капот), как работает вызов методов (obj.method()).

Присмотревшись поближе, в выражении obj.method() можно заметить две операции:

Сначала оператор точка '.' возвращает свойство объекта – его метод (obj.method).
Затем скобки () вызывают этот метод (исполняется код метода).
Итак, каким же образом информация о this передаётся из первой части во вторую?

Если мы поместим эти операции в отдельные строки, то значение this, естественно, будет потеряно:

*/

let user = {
  name: "Джон",
  hi() { alert(this.name); }
};

// разделим получение метода объекта и его вызов в разных строках
let hi = user.hi;
hi(); // Ошибка, потому что значением this является undefined

/*

Здесь hi = user.hi сохраняет функцию в переменной, и далее в последней строке она вызывается полностью сама по себе, без объекта, так что нет this.

Для работы вызовов типа user.hi(), JavaScript использует трюк – точка '.' возвращает 
не саму функцию, а специальное значение «ссылочного типа», называемого Reference Type. 

Этот ссылочный тип (Reference Type) является внутренним типом. Мы не можем явно использовать его, но он используется внутри языка.
Значение ссылочного типа – это «триплет»: комбинация из трёх значений (base, name, strict), где:

base – это объект.
name – это имя свойства объекта.
strict – это режим исполнения. Является true, если действует строгий режим (use strict).
Результатом доступа к свойству user.hi является не функция, а значение ссылочного типа. Для user.hi в строгом режиме оно будет таким:

*/

// значение ссылочного типа (Reference Type)
(user, "hi", true)

/*

Когда скобки () применяются к значению ссылочного типа (происходит вызов), то они получают полную информацию об объекте и его методе, 
и могут поставить правильный this (=user в данном случае, по base).

Ссылочный тип – исключительно внутренний, промежуточный, используемый, чтобы передать информацию от точки . до вызывающих скобок ().

При любой другой операции, например, присваивании hi = user.hi, ссылочный тип заменяется на собственно значение user.hi (функцию), 
и дальше работа уже идёт только с ней. Поэтому дальнейший вызов происходит уже без this.

Таким образом, значение this передаётся правильно, только если функция вызывается напрямую с использованием синтаксиса точки obj.method() 
или квадратных скобок obj['method']() (они делают то же самое). Позднее в этом учебнике мы изучим различные варианты решения проблемы потери значения this. 
Например, такие как func.bind().

*/

// Стрелочные функции особенные: у них нет своего «собственного» this. Если мы используем this внутри стрелочной функции, 
// то его значение берётся из внешней «нормальной» функции.
// Например, здесь arrow() использует значение this из внешнего метода user.sayHi():

let user = {
  firstName: "Илья",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Илья

/*

Это является особенностью стрелочных функций. Они полезны, когда мы на самом деле не хотим иметь отдельное значение this, а хотим брать его из внешнего контекста. 
Позднее в главе Повторяем стрелочные функции мы увидим больше примеров на эту тему.

*/

// ИТОГО

/*

Функции, которые находятся в объекте в качестве его свойств, называются «методами».
Методы позволяют объектам «действовать»: object.doSomething().
Методы могут ссылаться на объект через this.

Значение this определяется во время исполнения кода.

При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
Эта функция может быть скопирована между объектами (из одного объекта в другой).
Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является объект перед точкой.
Также ещё раз заметим, что стрелочные функции являются особенными – у них нет this. Когда внутри стрелочной функции обращаются к this, то его значение берётся снаружи.

*/

// Каким будет результат выполнения этого кода?

let user = {
  name: "Джон",
  go: function() { alert(this.name) }
}

(user.go)()

// Ошибка!

/* 

Сообщение об ошибке в большинстве браузеров не даёт понимания, что же пошло не так.
Ошибка появляется, потому что точка с запятой пропущена после user = {...}.
JavaScript не вставляет автоматически точку с запятой перед круглой скобкой (user.go)(), поэтому читает этот код так:
 
*/

let user = { go:... }(user.go)()

/*

Теперь мы тоже можем увидеть, что такое объединённое выражение синтаксически является вызовом объекта { go: ... } как функции с аргументом (user.go). 
И это происходит в той же строчке с объявлением переменной let user, т.е. объект user ещё даже не определён, поэтому получается ошибка.
Если мы вставим точку с запятой – всё заработает:

*/

let user = {
  name: "Джон",
  go: function() { alert(this.name) }
}; // точка с запятой стоит

(user.go)() // Джон

/* 

Обратите внимание, что круглые скобки вокруг (user.go) ничего не значат. Обычно они определяют последовательность операций (оператор группировки), 
но здесь вызов метода через точку . срабатывает первым в любом случае, поэтому группировка ни на что не влияет. Только точка с запятой имеет значение.

*/

/*

В представленном ниже коде мы намерены вызвать obj.go() метод 4 раза подряд.
Но вызовы (1) и (2) работают иначе, чем (3) и (4). Почему?

*/

let obj, method;

obj = {
  go: function() { alert(this); }
};

obj.go();               // (1) [object Object]

(obj.go)();             // (2) [object Object]

(method = obj.go)();    // (3) undefined

(obj.go || obj.stop)(); // (4) undefined

/*

Вот как это объясняется.
Это обычный вызов метода объекта через точку ., и this ссылается на объект перед точкой.
Здесь то же самое. Круглые скобки (оператор группировки) тут не изменяют порядок выполнения операций – доступ к методу через точку в любом случае срабатывает первым.
Здесь мы имеем более сложный вызов (expression).method(). Такой вызов работает, как если бы он был разделён на 2 строчки:

f = obj.go; // вычисляется выражение (переменная f ссылается на код функции)
f();        // вызов функции, на которую ссылается f
Здесь f() выполняется как функция, без передачи значения this.

Тут похожая ситуация на случай (3) – идёт потеря значения this.

Чтобы объяснить поведение в примерах (3) и (4), нам нужно помнить, что доступ к свойству (через точку или квадратные скобки) 
возвращает специальное значение ссылочного типа (Reference Type).

За исключением вызова метода, любая другая операция (подобно операции присваивания = или сравнения через логические операторы, например ||) 
превращает это значение в обычное, которое не несёт информации, позволяющей установить this.

*/

// Здесь функция makeUser возвращает объект.
// Каким будет результат при обращении к свойству объекта ref? Почему?

function makeUser() {
  return {
    name: "Джон",
    ref: this
  };
};

let user = makeUser();

alert( user.ref.name ); // Каким будет результат?

// Ошибка. Error: Cannot read property 'name' of undefined

/*

Это потому, что правила, которые определяют значение this, никак не смотрят на объявление объекта. Важен лишь момент вызова метода.
Здесь значение this внутри makeUser() является undefined, потому что makeUser() вызвана как функция, не через «точку» как метод.

Литерал объекта сам по себе не влияет на this. Значение this одно для всей функции и блоков кода в ней, литеральные объекты не меняют его.
Таким образом, при создании объекта ref: this берёт текущее значение this функции makeUser().

А вот противоположный случай:

*/

function makeUser() {
  return {
    name: "Джон",
    ref() {
      return this;
    }
  };
};

let user = makeUser();

alert( user.ref().name ); // Джон

// Теперь это работает, поскольку user.ref() вызывается как метод. И значением this становится объект перед точкой ..

/*

Создайте объект calculator (калькулятор) с тремя методами:

read() (читать) запрашивает два значения и сохраняет их как свойства объекта.
sum() (суммировать) возвращает сумму сохранённых значений.
mul() (умножить) перемножает сохранённые значения и возвращает результат.

*/

const calculator = {
  read() {
    this.quantity = prompt('Сколько операндов вам необходимо?', '2')

    for (let i = 0; i < this.quantity; i++) {
      this[i] = prompt(`Введите ${i+1}-е значение`, '')
    }
  },
  sum() {
    let sum = 0

    for (let i = 0; i < this.quantity; i++) {
      sum += +this[i]
    }

    return sum
  },
  mul() {
    let mul = 1
    
    for (let i = 0; i < this.quantity; i++) {
      mul *= +this[i]
    }

    return mul
  }
}

// console.log(calculator)

calculator.read()
console.log(calculator.sum())

// console.log(calculator)

console.log(calculator.mul())

// Решение из учебника

/*

let calculator = {
  sum() {
    return this.a + this.b;
  },

  mul() {
    return this.a * this.b;
  },

  read() {
    this.a = +prompt('a?', 0);
    this.b = +prompt('b?', 0);
  }
};

calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );

*/

// Цепь вызовов

let ladder = {
  step: 0,
  up() {
    this.step++;
    return this
  },
  down() {
    this.step--;
    return this
  },
  showStep: function() { // показывает текущую ступеньку
    alert( this.step );
    return this
  }
};

/*

Измените код методов up, down и showStep таким образом, чтобы их вызов можно было сделать по цепочке, например так:

*/

ladder.up().up().down().showStep(); // 1

// Такой подход широко используется в библиотеках JavaScript.

let ladder = {
  step: 0,
  up() {
    this.step++;
    return this /// !!!!!
  },
  down() {
    this.step--;
    return this /// !!!!!
  },
  showStep: function() { // показывает текущую ступеньку
    console.log( this.step );
    return this /// !!!!!
  }
};

// Решением является возврат самого объекта в каждом методе.

ladder.up().down().up().showStep()

// Мы также можем писать один вызов на одной строке. Для длинной цепи вызовов это более читабельно:

ladder
  .up()
  .up()
  .down()
  .up()
  .down()
  .showStep(); // 1

/* 

Обычный синтаксис {...} позволяет создать только один объект. Но зачастую нам нужно создать множество однотипных объектов, таких как пользователи, элементы меню и т.д.
Это можно сделать при помощи функции-конструктора и оператора "new".

Функции-конструкторы являются обычными функциями. Но есть два соглашения:

Имя функции-конструктора должно начинаться с большой буквы.
Функция-конструктор должна вызываться при помощи оператора "new".

Например:

*/

function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Вася");

alert(user.name); // Вася
alert(user.isAdmin); // false

/*

Когда функция вызывается как new User(...), происходит следующее:

Создаётся новый пустой объект, и он присваивается this.
Выполняется код функции. Обычно он модифицирует this, добавляет туда новые свойства.
Возвращается значение this.
Другими словами, вызов new User(...) делает примерно вот что:

*/

function User(name) {
  // this = {};  (неявно)

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

  // return this;  (неявно)
}

// То есть, результат вызова let user = new User("Вася") – это тот же объект, что и:

let user = {
  name: "Вася",
  isAdmin: false
};

/* 

Теперь, когда нам необходимо будет создать других пользователей, мы можем использовать new User("Маша"), new User("Даша") и т.д. 
Данная конструкция гораздо удобнее и читабельнее, чем каждый раз создавать литерал объекта. 
Это и является основной целью конструкторов – удобное повторное создание однотипных объектов.

Ещё раз заметим: технически любая функция может быть использована как конструктор. То есть, каждая функция может быть вызвана при 
помощи оператора new, и выполнится алгоритм, указанный выше в примере. Заглавная буква в названии функции является всеобщим соглашением 
по именованию, она как бы подсказывает разработчику, что данная функция является функцией-конструктором, и её нужно вызывать через new.

*/

// new function() { … }

// Если в нашем коде большое количество строк, создающих один сложный объект, мы можем обернуть их в функцию-конструктор следующим образом:

let user = new function() {
  this.name = "Вася";
  this.isAdmin = false;

  // ...другой код для создания пользователя
  // возможна любая сложная логика и выражения
  // локальные переменные и т. д.
};

/*

Такой конструктор не может быть вызван дважды, так как он нигде не сохраняется, просто создаётся и тут же вызывается. 
Таким образом, такой метод создания позволяет инкапсулировать код, который создаёт отдельный объект, но без возможности его повторного использования.

Продвинутая возможность
Данный метод используется очень редко. Вы можете пропустить эту секцию, если не хотите углубляться в детали языка.

Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при помощи оператора new или без него.

В случае, если функция вызвана при помощи new, то в new.target будет сама функция, в противном случае undefined.

*/

function User() {
  alert(new.target);
}

// без "new":
User(); // undefined

// с "new":
new User(); // function User { ... }

// Это можно использовать, чтобы отличить обычный вызов от вызова «в режиме конструктора». 
// В частности, вот так можно сделать, чтобы функцию можно было вызывать как с, так и без new:

function User(name) { /// !!!!!
  if (!new.target) { // в случае, если вы вызвали без оператора new
    return new User(name); // ...добавим оператор new за вас
  }

  this.name = name;
}

let vasya = User("Вася"); // переадресовывает вызовы на new User
alert(vasya.name); // Вася

/*

Такой подход иногда используется в библиотеках для создания более гибкого синтаксиса, 
который позволяет разработчикам вызывать функции при помощи оператора new или без него.

Впрочем, это не очень хорошая практика, так как отсутствие new может ввести разработчика в заблуждение. 
С оператором new мы точно знаем, что в итоге будет создан новый объект.

*/

// Возврат значения из конструктора return

/*

Обычно конструкторы ничего не возвращают явно. Их задача – записать все необходимое в this, который в итоге станет результатом.

Но если return всё же есть, то применяется простое правило:

При вызове return с объектом, будет возвращён объект, а не this.
При вызове return с примитивным значением, примитивное значение будет отброшено.
Другими словами, return с объектом возвращает объект, в любом другом случае конструктор вернёт this.

В примере ниже return возвращает объект вместо this:

*/

function BigUser() {

  this.name = "Вася";

  return { name: "Godzilla" };  // <-- возвращает этот объект
}

alert( new BigUser().name );  // Godzilla, получили этот объект

// А вот пример с пустым return (или мы могли бы поставить примитив после return, неважно)

function SmallUser() {

  this.name = "Вася";

  return; // <-- возвращает this
}

alert( new SmallUser().name );  // Вася

// Обычно у конструкторов отсутствует return. В данном блоке мы упомянули особое поведение с возвращаемыми объектами, чтобы не оставлять пробелов в изучении языка.

// Отсутствие скобок
// Кстати, мы можем не ставить скобки после new, если вызов конструктора идёт без аргументов.

let user = new User; // <-- без скобок
// то же, что и
let user = new User();

// Пропуск скобок считается плохой практикой, но синтаксис языка такое позволяет.

// Создание методов в конструкторе

/*

Использование конструкторов для создания объектов даёт большую гибкость. 
Можно передавать конструктору параметры, определяющие, как создавать объект, и что в него записывать.

В this мы можем добавлять не только свойства, но и методы.

Например, в примере ниже, new User(name) создаёт объект с данным именем name и методом sayHi:

*/

function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}

let vasya = new User("Вася");

vasya.sayHi(); // Меня зовут: Вася

/*
vasya = {
   name: "Вася",
   sayHi: function() { ... }
}
*/

// Для создания сложных объектов есть и более «продвинутый» синтаксис – классы, которые мы разберём позже.

/*

Функции-конструкторы или просто конструкторы являются обычными функциями, именовать которые следует с заглавной буквы.
Конструкторы следует вызывать при помощи оператора new. Такой вызов создаёт пустой this в начале выполнения и возвращает заполненный в конце.

Мы можем использовать конструкторы для создания множества похожих объектов.

JavaScript предоставляет функции-конструкторы для множества встроенных объектов языка: например, Date, Set и других, которые нам ещё предстоит изучить.

Объекты, мы к ним ещё вернёмся!
В этой главе мы рассмотрели базовые принципы объектов и конструкторов. 
Данная информация необходима нам для дальнейшего изучения типов данных и функций. 
Как только мы с ними разберёмся, мы вернёмся к объектам для более детального 
изучения в главах Прототипы, наследование и Классы.

*/

// Возможно ли создать функции A и B в примере ниже, где объекты равны new A()==new B()?

function A() { ... }
function B() { ... }

let a = new A;
let b = new B;

alert( a == b ); // true

/* 

Если да – приведите пример вашего кода.

Да, возможно.
Если функция возвращает объект, то вместо this будет возвращён этот объект.
Например, они могут вернуть один и тот же объект obj, определённый снаружи:

*/

let obj = {};

function A() { return obj; }
function B() { return obj; }

alert( new A() == new B() ); // true

/*

Создайте функцию-конструктор Calculator, который создаёт объекты с тремя методами:

read() запрашивает два значения при помощи prompt и сохраняет их значение в свойствах объекта.
sum() возвращает сумму введённых свойств.
mul() возвращает произведение введённых свойств.

*/

function Calculator() {
  this.read = function() { // Везде проставляем контекст
    this.quantity = prompt('Сколько операндов вам необходимо?', '2')

    for (let i = 0; i < this.quantity; i++) {
      this[i] = prompt(`Введите ${i+1}-е значение`, '')
    }
  },
  this.sum = function() {
    let sum = 0

    for (let i = 0; i < this.quantity; i++) {
      sum += +this[i]
    }

    return sum
  },
  this.mul = function() {
    let mul = 1
    
    for (let i = 0; i < this.quantity; i++) {
      mul *= +this[i]
    }

    return mul
  }
}

let calc = new Calculator();

calc.read()

console.log(calc.mul())

// // console.log(calculator)

// calculator.read()
// console.log(calculator.sum())

// // console.log(calculator)

// console.log(calculator.mul())

/*

Напишите функцию-конструктор Accumulator(startingValue).

Объект, который она создаёт, должен уметь следующее:

Хранить «текущее значение» в свойстве value. Начальное значение устанавливается в аргументе конструктора startingValue.
Метод read() использует prompt для получения числа и прибавляет его к свойству value.
Таким образом, свойство value является текущей суммой всего, что ввёл пользователь при вызовах метода read(), с учётом начального значения startingValue.

Ниже вы можете посмотреть работу кода:

*/

// let accumulator = new Accumulator(1); // начальное значение 1

// accumulator.read(); // прибавит ввод prompt к текущему значению
// accumulator.read(); // прибавит ввод prompt к текущему значению

// alert(accumulator.value); // выведет сумму этих значений

function Accumulator(startingValue) {
  this.value = startingValue,

  this.read = function() {
    this.value += +prompt('Введите число','2')
  }
}

let accumulator = new Accumulator(1); // начальное значение 1

accumulator.read(); // прибавит ввод prompt к текущему значению
accumulator.read(); // прибавит ввод prompt к текущему значению

alert(accumulator.value); // выведет сумму этих значений

// Опциональная цепочка '?.'

// Опциональная цепочка ?. — это безопасный способ доступа к свойствам вложенных объектов, даже если какое-либо из промежуточных свойств не существует.

/*

Если вы только начали читать учебник и изучать JavaScript, то, возможно, проблема вас ещё не коснулась, но она довольно распространена.
В качестве примера предположим, что у нас есть объекты user, которые содержат информацию о наших пользователях.

У большинства наших пользователей есть адреса в свойстве user.address с улицей user.address.street, но некоторые из них их не указали.
В таком случае, когда мы попытаемся получить user.address.street, а пользователь окажется без адреса, мы получим ошибку:

*/

let user = {}; // пользователь без свойства "address"
alert(user.address.street); // Ошибка!

/*

Это ожидаемый результат. JavaScript работает следующим образом. Поскольку user.address имеет значение undefined, попытка получить user.address.street завершается ошибкой.
Во многих практических случаях мы бы предпочли получить здесь undefined вместо ошибки (что означало бы «улицы нет»).

…Или ещё один пример. В веб-разработке мы можем получить объект, соответствующий элементу веб-страницы, с помощью специального вызова метода, 
такого как document.querySelector('.elem'), и он возвращает null, когда такого элемента нет.

*/

// document.querySelector('.elem') равен null, если элемента нет
let html = document.querySelector('.elem').innerHTML; // ошибка, если он равен null

/*

Ещё раз, если элемент не существует, мы получим сообщение об ошибке доступа к свойству .innerHTML у null. 
И в некоторых случаях, когда отсутствие элемента является нормальным, мы хотели бы избежать ошибки и просто принять html = null в качестве результата.

Как мы можем это сделать?
Очевидным решением было бы проверить значение с помощью if или условного оператора ?, прежде чем обращаться к его свойству, вот так:

*/

let user = {};

alert(user.address ? user.address.street : undefined);

/*

Это работает, тут нет ошибки… Но это довольно неэлегантно. 
Как вы можете видеть, "user.address" появляется в коде дважды.
Вот как то же самое выглядело бы для document.querySelector:

*/

let html = document.querySelector('.elem') ? document.querySelector('.elem').innerHTML : null;

/*

Как видно, поиск элемента document.querySelector('.elem') здесь вызывается дважды, что не очень хорошо.
Для более глубоко вложенных свойств это ещё менее красиво, поскольку потребуется больше повторений.

К примеру, давайте аналогично вычислим user.address.street.name.
Нам нужно проверить как user.address, так и user.address.street:

*/

let user = {}; // у пользователя нет адреса

alert(user.address ? user.address.street ? user.address.street.name : null : null);

// Это просто ужасно, у кого-то могут даже возникнуть проблемы с пониманием такого кода.
// Есть немного лучший способ написать это, используя оператор &&:

let user = {}; // пользователь без адреса

alert( user.address && user.address.street && user.address.street.name ); // undefined (без ошибки)

/*

Проход при помощи логического оператора И && через весь путь к свойству гарантирует, что 
все компоненты существуют (если нет, вычисление прекращается), но также не является идеальным.

Как вы можете видеть, имена свойств по-прежнему дублируются в коде. Например, в приведённом выше коде user.address появляется три раза.
Вот почему в язык была добавлена опциональная цепочка ?.. Чтобы решить эту проблему – раз и навсегда!

*/

/*

Опциональная цепочка ?. останавливает вычисление и возвращает undefined, если значение перед ?. равно undefined или null.

Далее в этой статье, для краткости, мы будем говорить, что что-то «существует», если оно не является null и не undefined.

Другими словами, value?.prop:

работает как value.prop, если значение value существует,
в противном случае (когда value равно undefined/null) он возвращает undefined.
Вот безопасный способ получить доступ к user.address.street, используя ?.:

*/

let user = {}; // пользователь без адреса

alert( user?.address?.street ); // undefined (без ошибки)

// ?. ЕСЛИ ОПЕРАНД СЛЕВА СУЩЕСТВУЕТ, ИДЁМ ДАЛЬШЕ, ЕСЛИ НЕТ, ВОЗВРАЩАЕМ UNDEFINED

// Код лаконичный и понятный, в нем вообще нет дублирования.
// А вот пример с document.querySelector:

let html = document.querySelector('.elem')?.innerHTML; // будет undefined, если элемента нет

// Считывание адреса с помощью user?.address работает, даже если объект user не существует:

let user = null;

alert( user?.address ); // undefined
alert( user?.address.street ); // undefined

/*

Обратите внимание: синтаксис ?. делает необязательным значение перед ним, но не какое-либо последующее.

Так например, в записи user?.address.street.name ?. позволяет user безопасно быть null/undefined (и в этом случае возвращает undefined), 
но это так только для user. Доступ к последующим свойствам осуществляется обычным способом. Если мы хотим, 
чтобы некоторые из них были необязательными, тогда нам нужно будет заменить больше . на ?..

Не злоупотребляйте опциональной цепочкой
Нам следует использовать ?. только там, где нормально, что чего-то не существует.

К примеру, если, в соответствии с логикой нашего кода, объект user должен существовать, 
но address является необязательным, то нам следует писать user.address?.street, но не user?.address?.street.

В этом случае, если вдруг user окажется undefined, мы увидим программную ошибку по этому поводу и исправим её. 
В противном случае, если слишком часто использовать ?., ошибки могут замалчиваться там, где это неуместно, и их будет сложнее отлаживать.

*/

// Переменная перед ?. должна быть объявлена
// Если переменной user вообще нет, то user?.anything приведёт к ошибке:

// ReferenceError: user is not defined
// user?.address;

//Переменная должна быть объявлена (к примеру, как let/const/var user или как параметр функции). 
// Опциональная цепочка работает только с объявленными переменными!

/*

Как было сказано ранее, ?. немедленно останавливает вычисление, если левая часть не существует.
Так что если после ?. есть какие-то вызовы функций или операции, то они не произойдут.

Например:

*/

let user = null;
let x = 0;

user?.sayHi(x++); // нет "user", поэтому выполнение не достигает вызова sayHi и x++

alert(x); // 0, значение не увеличилось

/*

Опциональная цепочка ?. — это не оператор, а специальная синтаксическая конструкция, которая также работает с функциями и квадратными скобками.

Например, ?.() используется для вызова функции, которая может не существовать.
В приведённом ниже коде у некоторых наших пользователей есть метод admin, а у некоторых его нет:

*/

let userAdmin = {
  admin() {
    alert("Я админ");
  }
};

let userGuest = {};

userAdmin.admin?.(); // Я админ

userGuest.admin?.(); // ничего не произойдет (такого метода нет)

/*

Здесь в обеих строках мы сначала используем точку (userAdmin.admin), чтобы получить свойство admin, 
потому что мы предполагаем, что объект user существует, так что читать из него безопасно.

Затем ?.() проверяет левую часть: если функция admin существует, то она запускается (это так для userAdmin). 
В противном случае (для userGuest) вычисление остановится без ошибок.

Синтаксис ?.[] также работает, если мы хотим использовать скобки [] для доступа к свойствам вместо точки .. 
Как и в предыдущих случаях, он позволяет безопасно считывать свойство из объекта, который может не существовать.

*/

let key = 'firstName';

let user1 = {
  firstName: 'John'
};

let user2 = null;

alert( user1?.[key] ); // John
alert( user2?.[key] ); // undefined

// Также мы можем использовать ?. с delete:
// delete user?.name; // удаляет user.name если пользователь существует

/*

Мы можем использовать ?. для безопасного чтения и удаления, но не для записи
Опциональная цепочка ?. не имеет смысла в левой части присваивания.

Например:

*/

let user = null;

user?.name = "John"; // Ошибка, не работает
// то же самое что написать undefined = "John"

/*

Синтаксис опциональной цепочки ?. имеет три формы:

obj?.prop – возвращает obj.prop если obj существует, в противном случае undefined.
obj?.[prop] – возвращает obj[prop] если obj существует, в противном случае undefined.
obj.method?.() – вызывает obj.method(), если obj.method существует, в противном случае возвращает undefined.
Как мы видим, все они просты и понятны в использовании. ?. проверяет левую часть на null/undefined и 
позволяет продолжить вычисление, если это не так.

Цепочка ?. позволяет безопасно получать доступ к вложенным свойствам.

Тем не менее, мы должны использовать ?. осторожно, только там, где по логике кода допустимо, 
что левая часть не существует. Чтобы он не скрывал от нас ошибки программирования, если они возникнут.

*/

// ТИП ДАННЫХ Symbol

/*

По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. 
Ни числа, ни логические значения не подходят, разрешены только эти два типа данных.

До сих пор мы видели только строки. Теперь давайте разберём символы, увидим, что хорошего они нам дают.

«Символ» представляет собой уникальный идентификатор.
Создаются новые символы с помощью функции Symbol():

*/

// Создаём новый символ - id
let id = Symbol();

// При создании символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:

// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");

/*

Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, 
это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.

Например, вот два символа с одинаковым описанием – но они не равны:

*/

let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false

/*

Если вы знаете Ruby или какой-то другой язык программирования, в котором есть своего рода «символы» – пожалуйста, будьте внимательны. 
Символы в JavaScript имеют свои особенности, и не стоит думать о них, как о символах в Ruby или в других языках.

Символы не преобразуются автоматически в строки
Большинство типов данных в JavaScript могут быть неявно преобразованы в строку. 
Например, функция alert принимает практически любое значение, автоматически преобразовывает его в строку, 
а затем выводит это значение, не сообщая об ошибке. Символы же особенные и не преобразуются автоматически.

К примеру, alert ниже выдаст ошибку:

*/

let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string

/*

Это – языковая «защита» от путаницы, ведь строки и символы – принципиально разные типы данных 
и не должны неконтролируемо преобразовываться друг в друга. Если же мы действительно хотим вывести 
символ с помощью alert, то необходимо явно преобразовать его с помощью метода .toString(), вот так:

*/

let id = Symbol("id");
alert(id.toString()); // Symbol(id), теперь работает

// Или мы можем обратиться к свойству symbol.description, чтобы вывести только описание:

let id = Symbol("id");
alert(id.description); // id

/*

Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.
Например, мы работаем с объектами user, которые принадлежат стороннему коду. Мы хотим добавить к ним идентификаторы.

Используем для этого символьный ключ:

*/

let user = {
  name: "Вася"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // мы можем получить доступ к данным по ключу-символу

/*

Почему же лучше использовать Symbol("id"), а не строку "id"?

Так как объект user принадлежит стороннему коду, и этот код также работает с ним, то нам не следует добавлять
к нему какие-либо поля. Это небезопасно. Но к символу сложно нечаянно обратиться, сторонний код вряд ли 
его вообще увидит, и, скорее всего, добавление поля к объекту не вызовет никаких проблем.

Кроме того, предположим, что другой скрипт для каких-то своих целей хочет записать собственный идентификатор в объект user. 
Этот скрипт может быть какой-то JavaScript-библиотекой, абсолютно не связанной с нашим скриптом.

Сторонний код может создать для этого свой символ Symbol("id"):

*/

// ...
let id = Symbol("id");

user[id] = "Их идентификатор";

/*

Конфликта между их и нашим идентификатором не будет, так как символы всегда уникальны, даже если их имена совпадают.
А вот если бы мы использовали строку "id" вместо символа, то тогда был бы конфликт:

*/

let user = { name: "Вася" };

// Объявляем в нашем скрипте свойство "id"
user.id = "Наш идентификатор";

// ...другой скрипт тоже хочет свой идентификатор...

user.id = "Их идентификатор"
// Ой! Свойство перезаписано сторонней библиотекой!

// Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные скобки. /// !!!!!
// Вот так:

let id = Symbol("id");

let user = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};

// Это вызвано тем, что нам нужно использовать значение переменной id в качестве ключа, а не строку «id».

// Символы игнорируются циклом for…in
// Свойства, чьи ключи – символы, не перебираются циклом for..in.

// Например:

let id = Symbol("id");

let user = {
  name: "Вася",
  age: 30,
  [id]: 123
};

for (let key in user) alert(key); // name, age (свойства с ключом-символом нет среди перечисленных)

// хотя прямой доступ по символу работает
alert( "Напрямую: " + user[id] );

/*

Это – часть общего принципа «сокрытия символьных свойств». Если другая библиотека или скрипт будут работать с нашим объектом, 
то при переборе они не получат ненароком наше символьное свойство. Object.keys(user) также игнорирует символы.

А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:

*/

let id = Symbol("id");

let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123

// Здесь нет никакого парадокса или противоречия. Так и задумано. Идея заключается в том, что, когда мы клонируем или объединяем объекты, 
// мы обычно хотим скопировать все свойства (включая такие свойства с ключами-символами, как, например, id в примере выше).

/*

Глобальные символы
Итак, как мы видели, обычно все символы уникальны, даже если их имена совпадают. Но иногда мы наоборот хотим, чтобы символы с одинаковыми именами 
были одной сущностью. Например, разные части нашего приложения хотят получить доступ к символу "id", подразумевая именно одно и то же свойство.

Для этого существует глобальный реестр символов. Мы можем создавать в нём символы и обращаться к ним позже, 
и при каждом обращении нам гарантированно будет возвращаться один и тот же символ.

Для чтения (или, при отсутствии, создания) символа из реестра используется вызов Symbol.for(key).

Он проверяет глобальный реестр и, при наличии в нём символа с именем key, возвращает его, 
иначе же создаётся новый символ Symbol(key) и записывается в реестр под ключом key.

Например:

*/

// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id === idAgain ); // true

// Символы, содержащиеся в реестре, называются глобальными символами. Если вам нужен символ, доступный везде в коде – используйте глобальные символы.

/*

Symbol.keyFor
Для глобальных символов, кроме Symbol.for(key), который ищет символ по имени, существует обратный метод: 
Symbol.keyFor(sym), который, наоборот, принимает глобальный символ и возвращает его имя.

К примеру:

*/

// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id

/*

Внутри метода Symbol.keyFor используется глобальный реестр символов для нахождения имени символа. 
Так что этот метод не будет работать для неглобальных символов. 
Если символ неглобальный, метод не сможет его найти и вернёт undefined.

Впрочем, для любых символов доступно свойство description.

Например:

*/

let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert( Symbol.keyFor(globalSymbol) ); // name, глобальный символ
alert( Symbol.keyFor(localSymbol) ); // undefined для неглобального символа

alert( localSymbol.description ); // name

/*

Существует множество «системных» символов, использующихся внутри самого JavaScript, и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов.

Эти символы перечислены в спецификации в таблице Well-known symbols:

Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.iterator
Symbol.toPrimitive
…и так далее.

В частности, Symbol.toPrimitive позволяет описать правила для объекта, согласно которым он будет преобразовываться к примитиву. 
Мы скоро увидим его применение.

С другими системными символами мы тоже скоро познакомимся, когда будем изучать соответствующие возможности языка.

// ИТОГО

Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.
Символы создаются вызовом функции Symbol(), в которую можно передать описание (имя) символа.

Даже если символы имеют одно и то же имя, это – разные символы. Если мы хотим, чтобы одноимённые символы были равны, 
то следует использовать глобальный реестр: вызов Symbol.for(key) возвращает (или создаёт) глобальный символ с key в качестве имени.
Многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.

Символы имеют два основных варианта использования:

«Скрытые» свойства объектов.
Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, 
мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в for..in, 
так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением, 
так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или использования.

Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.
Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. 
Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. 
Например, в дальнейших главах мы будем использовать Symbol.iterator для итераторов, 
Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее.

Технически символы скрыты не на 100%. Существует встроенный метод Object.getOwnPropertySymbols(obj) – с его помощью можно получить 
все свойства объекта с ключами-символами. Также существует метод Reflect.ownKeys(obj), который возвращает все ключи объекта, включая символьные. 
Так что они не совсем спрятаны. Но большинство библиотек, встроенных методов и синтаксических конструкций не используют эти методы.

*/

/*

Преобразование объектов в примитивы
Что произойдёт, если сложить два объекта obj1 + obj2, вычесть один из другого obj1 - obj2 или вывести их на экран, воспользовавшись alert(obj)?

JavaScript совершенно не позволяет настраивать, как операторы работают с объектами. 
В отличие от некоторых других языков программирования, таких как Ruby или C++, мы не можем 
реализовать специальный объектный метод для обработки сложения (или других операторов).

В случае таких операций, объекты автоматически преобразуются в примитивы, затем выполняется 
сама операция над этими примитивами, и на выходе мы получим примитивное значение.

Это важное ограничение: результатом obj1 + obj2 (или другой математической операции) не может быть другой объект!

К примеру, мы не можем создавать объекты, представляющие векторы или матрицы (или достижения или может ещё что-то), 
складывать их и ожидать в качестве результата «суммированный» объект. Такие архитектурные ходы автоматически оказываются «за бортом».

Итак, поскольку мы технически здесь мало что можем сделать, в реальных проектах нет математики с объектами. 
Если она всё же происходит, то за редким исключением, это из-за ошибок в коде.

В этой главе мы рассмотрим, как объект преобразуется в примитив и как это можно настроить.

У нас есть две цели:

Это позволит нам понять, что происходит в случае ошибок в коде, когда такая операция произошла случайно.
Есть исключения, когда такие операции возможны и вполне уместны. Например, вычитание или сравнение дат (Date объекты). 
Мы встретимся с ними позже.

// Правила преобразования

В главе Преобразование типов мы рассмотрели правила для числовых, строковых и логических преобразований примитивов. Но мы оставили пробел для объектов. Теперь, когда мы уже знаем о методах и символах, пришло время заполнить этот пробел.

Не существует преобразования к логическому значению. В логическом контексте все объекты являются true, всё просто. Существует лишь их числовое и строковое преобразование.
Числовое преобразование происходит, когда мы вычитаем объекты или применяем математические функции. Например, объекты Date (которые будут рассмотрены в главе Дата и время) могут быть вычтены, и результатом date1 - date2 будет разница во времени между двумя датами.
Что касается преобразований к строке – оно обычно происходит, когда мы выводим на экран объект при помощи alert(obj) и в подобных контекстах.
Мы можем реализовать свои преобразования к строкам и числам, используя специальные объектные методы.

Теперь давайте углубимся в детали. Это единственный путь для того, чтобы разобраться в нюансах этой темы.

// Хинты
Как JavaScript решает, какое преобразование применить?

Существует три варианта преобразования типов, которые происходят в различных ситуациях. Они называются «хинтами», как описано в спецификации:

"string"
Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку, например alert:

*/

// вывод
alert(obj);

// используем объект в качестве ключа
anotherObj[obj] = 123;

/*

Как JavaScript решает, какое преобразование применить?

Существует три варианта преобразования типов, которые происходят в различных ситуациях. Они называются «хинтами», как описано в спецификации:

"string"
Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку, например alert:

*/

// вывод
alert(obj);

// используем объект в качестве ключа
anotherObj[obj] = 123;

// "number"
// Для преобразования объекта к числу, в случае математических операций:

// явное преобразование
let num = Number(obj);

// математические (не считая бинарного плюса)
let n = +obj; // унарный плюс
let delta = date1 - date2;

// сравнения больше/меньше
let greater = user1 > user2;

/*

Большинство встроенных математических функций также включают в себя такое преобразование.

"default"
Происходит редко, когда оператор «не уверен», какой тип ожидать.

Например, бинарный плюс + может работать как со строками (объединяя их в одну), так и с числами (складывая их). Поэтому, если бинарный плюс получает объект в качестве аргумента, он использует хинт "default" для его преобразования.

Также, если объект сравнивается с помощью == со строкой, числом или символом, тоже неясно, какое преобразование следует выполнить, поэтому используется хинт "default".

*/

// бинарный плюс использует хинт "default"
let total = obj1 + obj2;

// obj == number использует хинт "default"
if (user == 1) { ... };

/*

Операторы сравнения больше/меньше, такие как < >, также могут работать как со строками, так и с числами. 
Тем не менее, по историческим причинам, они используют хинт "number", а не "default".

Впрочем на практике, всё немного проще.

Все встроенные объекты, за исключением одного (объект Date, который мы рассмотрим позже), реализуют "default" 
преобразование тем же способом, что и "number". И нам следует поступать так же.

Чтобы выполнить преобразование, JavaScript пытается найти и вызвать три следующих метода объекта:

Вызвать obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует,
Иначе. если хинт равен "string"
попробовать вызвать obj.toString() или obj.valueOf(), смотря какой из них существует.
Иначе, если хинт равен "number" или "default"
попробовать вызвать obj.valueOf() или obj.toString(), смотря какой из них существует.

*/

// Давайте начнём с первого метода. Есть встроенный символ с именем Symbol.toPrimitive, который следует использовать для обозначения метода преобразования, вот так:

obj[Symbol.toPrimitive] = function(hint) {
  // вот код для преобразования этого объекта в примитив
  // он должен вернуть примитивное значение
  // hint = чему-то из "string", "number", "default"
};

// Если метод Symbol.toPrimitive существует, он используется для всех хинтов, и больше никаких методов не требуется.
// Например, здесь объект user реализует его:

let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500

/*

Как мы можем видеть из кода, user становится либо строкой со своим описанием, либо суммой денег в зависимости от преобразования. 
Единый метод user[Symbol.toPrimitive] обрабатывает все случаи преобразования

toString/valueOf

Если нет Symbol.toPrimitive, тогда JavaScript пытается найти методы toString и valueOf:

Для хинта "string": вызвать метод toString, а если он не существует, то valueOf (таким образом, toString имеет приоритет при строковом преобразовании).
Для других хинтов: valueOf, а если он не существует, то toString (таким образом, valueOf имеет приоритет для математических операций).
Методы toString и valueOf берут своё начало с древних времён. Это не символы (символов тогда ещё не было), а скорее просто «обычные» методы со строковыми именами. 
Они предоставляют альтернативный «старомодный» способ реализации преобразования.

Эти методы должны возвращать примитивное значение. Если toString или valueOf возвращает объект, то он игнорируется (так же, как если бы метода не было).

По умолчанию обычный объект имеет следующие методы toString и valueOf:

Метод toString возвращает строку "[object Object]".
Метод valueOf возвращает сам объект.

Взгляните на пример:

*/

/* 

Таким образом, если мы попытаемся использовать объект в качестве строки, как например в alert или вроде того, то по умолчанию мы увидим [object Object].
Значение по умолчанию valueOf упоминается здесь только для полноты картины, чтобы избежать какой-либо путаницы. Как вы можете видеть, он возвращает
сам объект и поэтому игнорируется. Не спрашивайте меня почему, это по историческим причинам. Так что мы можем предположить, что его не существует.

Давайте применим эти методы для настройки преобразования.

Для примера, используем их в реализации всё того же объекта user. Но уже используя комбинацию toString и valueOf вместо Symbol.toPrimitive:

*/

let user = {
  name: "John",
  money: 1000,

  // для хинта равного "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // для хинта равного "number" или "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500

/*

Как видим, получилось то же поведение, что и в предыдущем примере с Symbol.toPrimitive.
Довольно часто нам нужно единое «универсальное» место для обработки всех примитивных преобразований. 
В этом случае мы можем реализовать только toString:

*/

let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500

// В отсутствие Symbol.toPrimitive и valueOf, toString обработает все примитивные преобразования.

/*

Преобразование может вернуть любой примитивный тип
Важная вещь, которую следует знать обо всех методах преобразования примитивов, заключается в том, что они не обязательно возвращают подсказанный хинтом примитив.

Нет никакого контроля над тем, вернёт ли toString именно строку, или чтобы метод Symbol.toPrimitive возращал именно число для хинта "number".

Единственное обязательное условие: эти методы должны возвращать примитив, а не объект.

// Историческая справка

По историческим причинам, если toString или valueOf вернёт объект, то ошибки не будет, но такое значение будет проигнорировано (как если бы метода вообще не существовало). Это всё потому, что в древние времена в JavaScript не было хорошей концепции «ошибки».

А вот Symbol.toPrimitive уже «четче», этот метод обязан возвращать примитив, иначе будет ошибка.

Дальнейшие преобразования
Как мы уже знаем, многие операторы и функции выполняют преобразования типов, например, умножение * преобразует операнды в числа.

Если мы передаём объект в качестве аргумента, то в вычислениях будут две стадии:

Объект преобразуется в примитив (с использованием правил, описанных выше).
Если необходимо для дальнейших вычислений, этот примитив преобразуется дальше.

Например:

*/

let obj = {
  // toString обрабатывает все преобразования в случае отсутствия других методов
  toString() {
    return "2";
  }
};

alert(obj * 2); // 4, объект был преобразован к примитиву "2", затем умножение сделало его числом

// Умножение obj * 2 сначала преобразует объект в примитив (это строка "2").
// Затем "2" * 2 становится 2 * 2 (строка преобразуется в число).
// А вот, к примеру, бинарный плюс в подобной ситуации соединил бы строки, так как он совсем не брезгует строк:

let obj = {
  toString() {
    return "2";
  }
};

alert(obj + 2); // 22 ("2" + 2), преобразование к примитиву вернуло строку => конкатенация

/*

Итого
Преобразование объекта в примитив вызывается автоматически многими встроенными функциями и операторами, которые ожидают примитив в качестве значения.

Существует всего 3 типа (хинта) для этого:

"string" (для alert и других операций, которым нужна строка)
"number" (для математических операций)
"default" (для некоторых других операторов, обычно объекты реализуют его как "number")
Спецификация явно описывает для каждого оператора, какой ему следует использовать хинт.

Алгоритм преобразования таков:

Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует,
В случае, если хинт равен "string"
происходит попытка вызвать obj.toString() и obj.valueOf(), смотря что есть.
В случае, если хинт равен "number" или "default"
происходит попытка вызвать obj.valueOf() и obj.toString(), смотря что есть.
Все эти методы должны возвращать примитив (если определены).

На практике часто бывает достаточно реализовать только obj.toString() в качестве универсального метода для преобразований 
к строке, который должен возвращать удобочитаемое представление объекта для целей логирования или отладки.

// МЕТОДЫ ПРИМИТИВОВ

JavaScript позволяет нам работать с примитивными типами данных – строками, числами и т.д., как будто они являются объектами. 
У них есть и методы. Мы изучим их позже, а сначала разберём, как это всё работает, потому что, конечно, примитивы – не объекты.

Давайте взглянем на ключевые различия между примитивами и объектами.

Примитив

Это – значение «примитивного» типа.
Есть 7 примитивных типов: string, number, boolean, symbol, null, undefined и bigint.
Объект

Может хранить множество значений как свойства.
Объявляется при помощи фигурных скобок {}, например: {name: "Рома", age: 30}. 
В JavaScript есть и другие виды объектов: например, функции тоже являются объектами.
Одна из лучших особенностей объектов – это то, что мы можем хранить функцию как одно из свойств объекта.

*/

let roma = {
  name: "Рома",
  sayHi: function() {
    alert("Привет, дружище!");
  }
};

roma.sayHi(); // Привет, дружище!

/*

Здесь мы создали объект roma с методом sayHi.

Существует множество встроенных объектов. Например, те, которые работают с датами, ошибками, HTML-элементами и т.д. Они имеют различные свойства и методы.

Однако у этих возможностей есть обратная сторона!

Объекты «тяжелее» примитивов. Они нуждаются в дополнительных ресурсах для поддержания внутренней структуры.

// Примитив как объект

Вот парадокс, с которым столкнулся создатель JavaScript:

Есть много всего, что хотелось бы сделать с примитивами, такими как строка или число. Было бы замечательно, если бы мы могли обращаться к ним при помощи методов.
Примитивы должны быть лёгкими и быстрыми насколько это возможно.
Выбранное решение, хотя выглядит оно немного неуклюже:

Примитивы остаются примитивами. Одно значение, как и хотелось.
Язык позволяет осуществлять доступ к методам и свойствам строк, чисел, булевых значений и символов.
Чтобы это работало, при таком доступе создаётся специальный «объект-обёртка», который предоставляет нужную функциональность, а после удаляется.
Каждый примитив имеет свой собственный «объект-обёртку», которые называются: String, Number, Boolean, Symbol и BigInt. 

Таким образом, они имеют разный набор методов.
К примеру, существует метод str.toUpperCase(), который возвращает строку в верхнем регистре.

Вот, как он работает:

*/

let str = "Привет";
alert( str.toUpperCase() ); // ПРИВЕТ

/*

Очень просто, не правда ли? Вот, что на самом деле происходит в str.toUpperCase():

Строка str – примитив. В момент обращения к его свойству, создаётся специальный объект, который знает значение строки и имеет такие полезные методы, как toUpperCase().
Этот метод запускается и возвращает новую строку (показывается в alert).
Специальный объект удаляется, оставляя только примитив str.

Получается, что примитивы могут предоставлять методы, и в то же время оставаться «лёгкими».

Движок JavaScript сильно оптимизирует этот процесс. Он даже может пропустить создание специального объекта. 
Однако, он всё же должен придерживаться спецификаций и работать так, как будто он его создаёт.

Число имеет собственный набор методов. Например, toFixed(n) округляет число до n знаков после запятой.

*/

let n = 1.23456;

alert( n.toFixed(2) ); // 1.23

// Более подробно с различными свойствами и методами мы познакомимся в главах Числа и Строки.

/*

Конструкторы String/Number/Boolean предназначены только для внутреннего пользования
Некоторые языки, такие как Java, позволяют явное создание «объектов-обёрток» для примитивов при помощи такого синтаксиса как new Number(1) или new Boolean(false).

В JavaScript, это тоже возможно по историческим причинам, но очень не рекомендуется. В некоторых местах последствия могут быть катастрофическими.

Например:

*/

alert( typeof 0 ); // "число"

alert( typeof new Number(0) ); // "object"!

// Объекты в if всегда дают true, так что в нижеприведённом примере будет показан alert:

let zero = new Number(0);

if (zero) {
  // zero возвращает "true", так как является объектом
  alert( "zero имеет «истинное» значение?!?" );
}

/*

С другой стороны, использование функций String/Number/Boolean без оператора new – вполне разумно и полезно. 
Они превращают значение в соответствующий примитивный тип: в строку, в число, в булевый тип.

К примеру, следующее вполне допустимо:

*/

let num = Number("123"); // превращает строку в число

/*

null/undefined не имеют методов
Особенные примитивы null и undefined являются исключениями. 
У них нет соответствующих «объектов-обёрток», и они не имеют никаких методов. 
В некотором смысле, они «самые примитивные».

Попытка доступа к свойствам такого значения возвратит ошибку:

*/

alert(null.test); // ошибка

/*

// ИТОГО

Все примитивы, кроме null и undefined, предоставляют множество полезных методов. Мы познакомимся с ними поближе в следующих главах.
Формально эти методы работают с помощью временных объектов, но движки JavaScript внутренне очень хорошо оптимизируют этот процесс, 
так что их вызов не требует много ресурсов.

*/

let str = "Привет";

str.test = 5;

alert(str.test);

// Как вы думаете, это сработает? Что выведется на экран?

/*

В зависимости от того, используете ли вы строгий режим (use strict) или нет, результат может быть:

undefined (без strict)
Ошибка (strict mode)
Почему? Давайте посмотрим что происходит в строке кода, отмеченной (*):

В момент обращения к свойству str создаётся «объект-обёртка».
В строгом режиме, попытка изменения этого объекта выдаёт ошибку.
Без строгого режима, операция продолжается, объект получает свойство test, 
но после этого он удаляется, так что на последней линии str больше не имеет свойства test.

Данный пример наглядно показывает, что примитивы не являются объектами. !!!!!

Они не могут хранить дополнительные данные.

*/

// ЧИСЛА

/*

В современном JavaScript существует два типа чисел:

Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, который также называют 
«числа с плавающей точкой двойной точности» (double precision floating point numbers). 
Это числа, которые мы будем использовать чаще всего. Мы поговорим о них в этой главе.
BigInt числа дают возможность работать с целыми числами произвольной длины. Они нужны достаточно редко 
и используются в случаях, когда необходимо работать со значениями более чем 253 или менее чем -253. 
Так как BigInt числа нужны достаточно редко, мы рассмотрим их в отдельной главе BigInt.

В данной главе мы рассмотрим только первый тип чисел: числа типа number. Давайте глубже изучим, как с ними работать в JavaScript.

Способы записи числа
Представьте, что нам надо записать число 1 миллиард. Самый очевидный путь:

*/

let billion = 1000000000;

/*

Но в реальной жизни мы обычно опускаем запись множества нулей, так как можно легко ошибиться. 
Укороченная запись может выглядеть как "1млрд" или "7.3млрд" для 7 миллиардов 300 миллионов. 
Такой принцип работает для всех больших чисел.

В JavaScript можно использовать букву "e", чтобы укоротить запись числа. 
Она добавляется к числу и заменяет указанное количество нулей:

*/

let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей

alert( 7.3e9 );  // 7.3 миллиардов (7,300,000,000)

// Другими словами, "e" производит операцию умножения числа на 1 с указанным количеством нулей.

1e3 = 1 * 1000
1.23e6 = 1.23 * 1000000

// Сейчас давайте запишем что-нибудь очень маленькое. К примеру, 1 микросекунду (одна миллионная секунды):

let ms = 0.000001;

// Записать микросекунду в укороченном виде нам поможет "e".

let ms = 1e-6; // шесть нулей, слева от 1

/*

Если мы подсчитаем количество нулей 0.000001, их будет 6. Естественно, верная запись 1e-6.

Другими словами, отрицательное число после "e" подразумевает деление на 1 с указанным количеством нулей:

*/

// 1 делится на 1 с 3 нулями
1e-3 = 1 / 1000 (=0.001)

// 1.23 делится на 1 с 6 нулями
1.23e-6 = 1.23 / 1000000 (=0.00000123)

/*

Шестнадцатеричные числа широко используются в JavaScript для представления цветов, кодировки символов и многого другого. 
Естественно, есть короткий стиль записи: 0x, после которого указывается число.

Например:

*/

alert( 0xff ); // 255
alert( 0xFF ); // 255 (то же самое, регистр не имеет значения)

// Не так часто используются двоичные и восьмеричные числа, но они также поддерживаются 0b для двоичных и 0o для восьмеричных:

let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

alert( a == b ); // true, с двух сторон число 255

// Есть только 3 системы счисления с такой поддержкой. Для других систем счисления мы рекомендуем использовать функцию parseInt (рассмотрим позже в этой главе).

// toString(base)

// Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.

// Например:

let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111

/*

base может варьироваться от 2 до 36 (по умолчанию 10).

Часто используемые:

base=16 — для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть 0..9 или A..F.

base=2 — обычно используется для отладки побитовых операций, цифры 0 или 1.

base=36 — максимальное основание, цифры могут быть 0..9 или A..Z. То есть, используется весь латинский алфавит для представления числа. 
Забавно, но можно использовать 36-разрядную систему счисления для получения короткого представления большого числового идентификатора. 
К примеру, для создания короткой ссылки. Для этого просто преобразуем его в 36-разрядную систему счисления:

*/

alert( 123456..toString(36) ); // 2n9c

/*

Две точки для вызова метода
Внимание! Две точки в 123456..toString(36) это не опечатка. Если нам надо вызвать метод непосредственно на числе, 
как toString в примере выше, то нам надо поставить две точки .. после числа.

Если мы поставим одну точку: 123456.toString(36), тогда это будет ошибкой, поскольку синтаксис JavaScript 
предполагает, что после первой точки начинается десятичная часть. А если поставить две точки, то JavaScript 
понимает, что десятичная часть отсутствует, и начинается метод.

Также можно записать как (123456).toString(36). !!!

// ОКРУГЛЕНИЕ

Одна из часто используемых операций при работе с числами – это округление.

В JavaScript есть несколько встроенных функций для работы с округлением:

Math.floor
Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
Math.ceil
Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
Math.round
Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
Math.trunc (не поддерживается в Internet Explorer)
Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.
Ниже представлена таблица с различиями между функциями округления:

Эти функции охватывают все возможные способы обработки десятичной части. Что если нам надо округлить число до n-ого количества цифр в дробной части?

Например, у нас есть 1.2345 и мы хотим округлить число до 2-х знаков после запятой, оставить только 1.23.

Есть два пути решения:

Умножить и разделить.

Например, чтобы округлить число до второго знака после запятой, мы можем умножить число на 100, вызвать функцию округления и разделить обратно.

*/

let num = 1.23456;

alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23

// Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.

let num = 12.34;
alert( num.toFixed(1) ); // "12.3"

// Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу Math.round:

let num = 12.36;
alert( num.toFixed(1) ); // "12.4"

// Обратите внимание, что результатом toFixed является строка. Если десятичная часть короче, чем необходима, будут добавлены нули в конец строки:

let num = 12.34;
alert( num.toFixed(5) ); // "12.34000", добавлены нули, чтобы получить 5 знаков после запятой

// Мы можем преобразовать полученное значение в число, используя унарный оператор + или Number(), пример с унарным оператором: +num.toFixed(5).

/*

Неточные вычисления
Внутри JavaScript число представлено в виде 64-битного формата IEEE-754. Для хранения числа используется 64 бита: 
52 из них используется для хранения цифр, 11 из них для хранения положения десятичной точки (если число целое, то хранится 0), и один бит отведён на хранение знака.

Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность:

*/

alert( 1e500 ); // Infinity

// Наиболее часто встречающаяся ошибка при работе с числами в JavaScript – это потеря точности.
// Посмотрите на это (неверное!) сравнение:

alert( 0.1 + 0.2 == 0.3 ); // false

// Да-да, сумма 0.1 и 0.2 не равна 0.3.
// Странно! Что тогда, если не 0.3?

alert( 0.1 + 0.2 ); // 0.30000000000000004

/*

Ой! Здесь гораздо больше последствий, чем просто некорректное сравнение. Представьте, вы делаете интернет-магазин и посетители формируют 
заказ из 2-х позиций за $0.10 и $0.20. Итоговый заказ будет $0.30000000000000004. Это будет сюрпризом для всех.

Но почему это происходит?

Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. Но дроби, такие как 0.1, 0.2, 
которые выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме.

Другими словами, что такое 0.1? Это единица делённая на десять — 1/10, одна десятая. В десятичной системе счисления 
такие числа легко представимы, по сравнению с одной третьей: 1/3, которая становится бесконечной дробью 0.33333(3).

Деление на 10 гарантированно хорошо работает в десятичной системе, но деление на 3 – нет. По той же причине 
и в двоичной системе счисления, деление на 2 обязательно сработает, а 1/10 становится бесконечной дробью.

В JavaScript нет возможности для хранения точных значений 0.1 или 0.2, используя двоичную систему, 
точно также, как нет возможности хранить одну третью в десятичной системе счисления.

Числовой формат IEEE-754 решает эту проблему путём округления до ближайшего возможного числа. 
Правила округления обычно не позволяют нам увидеть эту «крошечную потерю точности», но она существует.

Пример:

*/

alert( 0.1.toFixed(20) ); // 0.10000000000000000555

// И когда мы суммируем 2 числа, их «неточности» тоже суммируются.
// Вот почему 0.1 + 0.2 – это не совсем 0.3.

/*

Не только в JavaScript!

Справедливости ради заметим, что ошибка в точности вычислений для чисел с плавающей точкой 
сохраняется в любом другом языке, где используется формат IEEE 754, включая PHP, Java, C, Perl, Ruby.

Можно ли обойти проблему? Конечно, наиболее надёжный способ — это округлить результат используя метод toFixed(n):

*/

let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30

/*

Помните, что метод toFixed всегда возвращает строку. Это гарантирует, что результат будет с заданным количеством цифр в десятичной части. 
Также это удобно для форматирования цен в интернет-магазине $0.30. В других случаях можно использовать унарный оператор +, чтобы преобразовать строку в число:

*/

let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3

/* 

Также можно временно умножить число на 100 (или на большее), чтобы привести его к целому, выполнить математические действия, а после разделить обратно. 
Суммируя целые числа, мы уменьшаем погрешность, но она всё равно появляется при финальном делении: 

*/

alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001

/*

Таким образом, метод умножения/деления уменьшает погрешность, но полностью её не решает.

Иногда можно попробовать полностью отказаться от дробей. Например, если мы в нашем интернет-магазине начнём использовать центы вместо долларов. 
Но что будет, если мы применим скидку 30%? На практике у нас не получится полностью избавиться от дроби. 
Просто используйте округление, чтобы отрезать «хвосты», когда надо.

Забавный пример
Попробуйте выполнить его:

*/

// Привет! Я – число, растущее само по себе!
alert( 9999999999999999 ); // покажет 10000000000000000

/*

Причина та же – потеря точности. Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, остальные 11 бит хранят 
позицию десятичной точки и один бит – знак. Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.

Интерпретатор не выдаст ошибку, но в результате получится «не совсем то число», что мы и видим в примере выше. Как говорится: «как смог, так записал».

// Два нуля

Другим забавным следствием внутреннего представления чисел является наличие двух нулей: 0 и -0.

Все потому, что знак представлен отдельным битом, так что, любое число может быть положительным и отрицательным, включая нуль.

В большинстве случаев это поведение незаметно, так как операторы в JavaScript воспринимают их одинаковыми.

// Проверка: isFinite и isNaN

Помните эти специальные числовые значения?

Infinity (и -Infinity) — особенное численное значение, которое ведёт себя в точности как математическая бесконечность ∞.
NaN представляет ошибку.
Эти числовые значения принадлежат типу number, но они не являются «обычными» числами, поэтому есть функции для их проверки:

isNaN(value) преобразует значение в число и проверяет является ли оно NaN:

*/

alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true

/*

Нужна ли нам эта функция? Разве не можем ли мы просто сравнить === NaN? К сожалению, нет. 
Значение NaN уникально тем, что оно не является равным ни чему другому, даже самому себе:

*/

alert( NaN === NaN ); // false

// isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:

alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, потому что специальное значение: NaN
alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity

// Иногда isFinite используется для проверки, содержится ли в строке число:

let num = +prompt("Enter a number", '');

// вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
alert( isFinite(num) );

// Помните, что пустая строка интерпретируется как 0 во всех числовых функциях, включая isFinite

/*

Сравнение Object.is
Существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:

Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.
Во всех других случаях Object.is(a, b) идентичен a === b.

Этот способ сравнения часто используется в спецификации JavaScript. Когда внутреннему алгоритму необходимо
сравнить 2 значения на предмет точного совпадения, он использует Object.is (Определение SameValue).

// parseInt и parseFloat

Для явного преобразования к числу можно использовать + или Number(). Если строка не является в точности числом, то результат будет NaN:

*/

alert( +"100px" ); // NaN

/*

Единственное исключение — это пробелы в начале строки и в конце, они игнорируются.

В реальной жизни мы часто сталкиваемся со значениями у которых есть единица измерения, например "100px" или "12pt" в CSS. 
Также во множестве стран символ валюты записывается после номинала "19€". Так как нам получить числовое значение из таких строк?

Для этого есть parseInt и parseFloat.

Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. 
Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой:

*/

alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, вернётся только целая часть
alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке

// Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру:

alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения

/*

Второй аргумент parseInt(str, radix)
Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, 
таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:

*/

alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает

alert( parseInt('2n9c', 36) ); // 123456

// Другие математические функции

/*

В JavaScript встроен объект Math, который содержит различные математические функции и константы.

Несколько примеров:

Math.random()
Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)

*/

alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (любое количество псевдослучайных чисел)

Math.max(a, b, c...) / Math.min(a, b, c...)

// Возвращает наибольшее/наименьшее число из перечисленных аргументов.

alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1

// Math.pow(n, power)
// Возвращает число n, возведённое в степень power

alert( Math.pow(2, 10) ); // 2 в степени 10 = 1024

// В объекте Math есть множество функций и констант, включая тригонометрические функции, 
// подробнее можно ознакомиться в документации по объекту Math.

// ИТОГО

/*

Чтобы писать числа с большим количеством нулей:

Используйте краткую форму записи чисел – "e", с указанным количеством нулей. Например: 123e6 это 123 с 6-ю нулями 123000000.
Отрицательное число после "e" приводит к делению числа на 1 с указанным количеством нулей. Например: 123e-6 это 0.000123 (123 миллионных).
Для других систем счисления:

Можно записывать числа сразу в шестнадцатеричной (0x), восьмеричной (0o) и бинарной (0b) системах счисления
parseInt(str, base) преобразует строку в целое число в соответствии с указанной системой счисления: 2 ≤ base ≤ 36.
num.toString(base) представляет число в строковом виде в указанной системе счисления base.
Для преобразования значений типа 12pt и 100px в число:

Используйте parseInt/parseFloat для «мягкого» преобразования строки в число, данные функции 
по порядку считывают число из строки до тех пор пока не возникнет ошибка.

Для дробей:

Используйте округления Math.floor, Math.ceil, Math.trunc, Math.round или num.toFixed(precision).
Помните, что при работе с дробями происходит потеря точности.
Ещё больше математических функций:

Документация по объекту Math. Библиотека маленькая, но содержит всё самое важное.

*/

// Создайте скрипт, который запрашивает ввод двух чисел (используйте prompt) и после показывает их сумму.

let firstNumber = +prompt('Первое число')
let secondNumber = +prompt('Второе число')

let result = firstNumber + secondNumber
console.log(result.toFixed())  

// Методы Math.round и toFixed, согласно документации, округляют до ближайшего целого числа: 0..4 
// округляется в меньшую сторону, тогда как 5..9 в большую сторону.
// Например:

alert( 1.35.toFixed(1) ); // 1.4

// Но почему в примере ниже 6.35 округляется до 6.3?

alert( 6.35.toFixed(1) ); // 6.3

// Как правильно округлить 6.35?

// Во внутреннем двоичном представлении 6.35 является бесконечной двоичной дробью. Хранится она с потерей точности…

alert( 6.35.toFixed(20) ); // 6.34999999999999964473

/*

Потеря точности может как увеличивать, так и уменьшать число. 
В данном случае число становится чуть меньше, поэтому оно округляется в меньшую сторону.

А для числа 1.35?

*/

alert( 1.35.toFixed(20) ); // 1.35000000000000008882

/*

Тут потеря точности приводит к увеличению числа, поэтому округление произойдёт в большую сторону.

Каким образом можно исправить ошибку в округлении числа 6.35?

Мы должны приблизить его к целому числу, перед округлением:

*/

alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000

/*

Обратите внимание, что для числа 63.5 не происходит потери точности. Дело в том, что десятичная часть 0.5 на самом деле 1/2. 
Дробные числа, делённые на степень 2, точно представлены в двоичной системе, теперь мы можем округлить число:

*/

alert( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4

/*

Создайте функцию readNumber, которая будет запрашивать ввод числового значения до тех пор, пока посетитель его не введёт.

Функция должна возвращать числовое значение.

Также надо разрешить пользователю остановить процесс ввода, отправив пустую строку или нажав «Отмена». В этом случае функция должна вернуть null.

*/

const readNumber = () => {
  let enteredNumber

  do {
    enteredNumber = prompt('Введите число', '')
  } while ( !isFinite(num) );

  if (enteredNumber === null || enteredNumber === '') return null

  return +num
}

console.log(readNumber())


/*

Решение немного сложнее, чем могло бы быть, потому что нам надо обрабатывать null и пустую строку.

Следовательно, запрашиваем ввод числового значения, пока посетитель его не введёт. И null (отмена) 
и пустая строка также соответствуют данному условию, потому что при приведении к числу они равны 0.

После того, как цикл завершится, нам нужно проверить введённое значение на null и пустую строку (вернуть null), 
потому что после преобразования null в число, функция вернёт 0.

Этот цикл – бесконечный. Он никогда не завершится, почему?

*/

let i = 0;
while (i != 10) {
  i += 0.2;
}

// Потому что i никогда не станет равным 10.

// 9.999999999999996
// 10.199999999999996

// Ни одно из этих чисел не равно 10.
// Это происходит из-за потери точности, при прибавлении таких дробей как 0.2.
// Вывод: избегайте проверок на равенство при работе с десятичными дробями.

/*

Случайное число от min до max

Встроенный метод Math.random() возвращает случайное число от 0 (включительно) до 1 (но не включая 1)
Напишите функцию random(min, max), которая генерирует случайное число с плавающей точкой от min до max (но не включая max).

Пример работы функции:

*/

const random = (min, max) => {
  return Math.random() * (max - min)
}

alert( random(1, 5) ); // 1.2345623452
alert( random(1, 5) ); // 3.7894332423
alert( random(1, 5) ); // 4.3435234525

/*

Напишите функцию randomInteger(min, max), которая генерирует случайное целое (integer) число от min до max (включительно).
Любое число из интервала min..max должно появляться с одинаковой вероятностью.

Пример работы функции:

*/

const random = (min, max) => {
  return min + Math.random() * (max - min)
}

alert( randomInteger(1, 5) ); // 1
alert( randomInteger(1, 5) ); // 3
alert( randomInteger(1, 5) ); // 5

// Случайное целое число от min до max

/*

Напишите функцию randomInteger(min, max), которая генерирует случайное целое (integer) число от min до max (включительно).

Любое число из интервала min..max должно появляться с одинаковой вероятностью.

Пример работы функции:

*/

const random = (min, max) => {
  return (min + Math.random() * (max - min)).toFixed()
}

alert( randomInteger(1, 5) ); // 1
alert( randomInteger(1, 5) ); // 3
alert( randomInteger(1, 5) ); // 5

// Строки

/*

В JavaScript любые текстовые данные являются строками. Не существует отдельного типа «символ», который есть в ряде других языков.
Внутренний формат для строк — всегда UTF-16, вне зависимости от кодировки страницы.

// Кавычки

В JavaScript есть разные типы кавычек.
Строку можно создать с помощью одинарных, двойных либо обратных кавычек:

*/

let single = 'single-quoted';
let double = "double-quoted";

let backticks = `backticks`;

/* 

Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки, 
то в такую строку мы сможем вставлять произвольные выражения, обернув их в ${…}:

*/

function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.

// Ещё одно преимущество обратных кавычек — они могут занимать более одной строки, вот так:

let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // список гостей, состоящий из нескольких строк

// Выглядит вполне естественно, не правда ли? Что тут такого? Но если попытаться 
// использовать точно так же одинарные или двойные кавычки, то будет ошибка:

let guestList = "Guests: // Error: Unexpected token ILLEGAL
  * John";

/*

Одинарные и двойные кавычки в языке с незапамятных времён: тогда потребность в многострочных строках не учитывалась. Что касается обратных кавычек, они появились существенно позже, и поэтому они гибче.

Обратные кавычки также позволяют задавать «шаблонную функцию» перед первой обратной кавычкой. Используемый синтаксис: func`string`. 
Автоматически вызываемая функция func получает строку и встроенные в неё выражения и может их обработать. 
Подробнее об этом можно прочитать в документации. Если перед строкой есть выражение, то шаблонная строка называется «теговым шаблоном». 
Это позволяет использовать свою шаблонизацию для строк, но на практике теговые шаблоны применяются редко.

*/

/* Многострочные строки также можно создавать с помощью одинарных и двойных кавычек, 
используя так называемый «символ перевода строки», который записывается как \n: */

let guestList = "Guests:\n * John\n * Pete\n * Mary";

alert(guestList); // список гостей, состоящий из нескольких строк

// В частности, эти две строки эквивалентны, просто записаны по-разному:

// перевод строки добавлен с помощью символа перевода строки
let str1 = "Hello\nWorld";

// многострочная строка, созданная с использованием обратных кавычек
let str2 = `Hello
World`;

alert(str1 == str2); // true

// Есть и другие, реже используемые спецсимволы. Вот список:

// \n – Перевод строки

/* 

\r – В текстовых файлах Windows для перевода строки используется комбинация символов \r\n, 
а на других ОС это просто \n. Это так по историческим причинам, 
ПО под Windows обычно понимает и просто \n.

*/

// \', \"	– Кавычки

// \\	– Обратный слеш

// \t	– Знак табуляции

// \b, \f, \v	– Backspace, Form Feed и Vertical Tab — оставлены для обратной совместимости, сейчас не используются.

// \xXX – Символ с шестнадцатеричным Юникодным кодом XX, например, '\x7A' — то же самое, что 'z'.

/* 

\uXXXX	– Символ в кодировке UTF-16 с шестнадцатеричным кодом XXXX, например, \u00A9 — Юникодное представление знака копирайта, 
©. Код должен состоять ровно из 4 шестнадцатеричных цифр.

*/ 

/* 

\u{X…XXXXXX} (от 1 до 6 шестнадцатеричных цифр) – Символ в кодировке UTF-32 с шестнадцатеричным кодом от U+0000 до U+10FFFF. 
Некоторые редкие символы кодируются двумя 16-битными словами и занимают 4 байта. Так можно вставлять символы с длинным кодом.

*/

// Примеры с Юникодом:

alert( "\u00A9" ); // ©
alert( "\u{20331}" ); // 佫, редкий китайский иероглиф (длинный Юникод)
alert( "\u{1F60D}" ); // 😍, символ улыбающегося лица (еще один длинный Юникод)

/* 

Все спецсимволы начинаются с обратного слеша, \ — так называемого «символа экранирования».
Он также используется, если необходимо вставить в строку кавычку.

К примеру:

*/

alert( 'I\'m the Walrus!' ); // I'm the Walrus!

/*

Здесь перед входящей в строку кавычкой необходимо добавить обратный слеш — \' — иначе она бы обозначала окончание строки.

Разумеется, требование экранировать относится только к таким же кавычкам, как те, в которые заключена строка. 
Так что мы можем применить и более элегантное решение, использовав для этой строки двойные или обратные кавычки:

*/

alert( `I'm the Walrus!` ); // I'm the Walrus!

/*

Заметим, что обратный слеш \ служит лишь для корректного прочтения строки интерпретатором, но он не записывается в строку после её прочтения. 
Когда строка сохраняется в оперативную память, в неё не добавляется символ \. Вы можете явно видеть это в выводах alert в примерах выше.

Но что, если нам надо добавить в строку собственно сам обратный слеш \?
Это можно сделать, добавив перед ним… ещё один обратный слеш!

*/

alert( `The backslash: \\` ); // The backslash: \

/* 

Длина строки
Свойство length содержит длину строки:

*/

alert( `My\n`.length ); // 3

// Обратите внимание, \n — это один спецсимвол, поэтому тут всё правильно: длина строки 3.

// length — это свойство
// Бывает так, что люди с практикой в других языках случайно пытаются вызвать его, добавляя круглые скобки: они пишут str.length() вместо str.length. Это не работает.

// Так как str.length — это числовое свойство, а не функция, добавлять скобки не нужно.

/* 

Доступ к символам
Получить символ, который занимает позицию pos, можно с помощью квадратных скобок: [pos]. 
cТакже можно использовать метод charAt: str.charAt(pos). Первый символ занимает нулевую позицию:

*/

let str = `Hello`;

// получаем первый символ
alert( str[0] ); // H
alert( str.charAt(0) ); // H

// получаем последний символ
alert( str[str.length - 1] ); // o

// Квадратные скобки — современный способ получить символ, в то время как charAt существует в основном по историческим причинам.
// Разница только в том, что если символ с такой позицией отсутствует, тогда [] вернёт undefined, а charAt — пустую строку:

let str = `Hello`;

alert( str[1000] ); // undefined
alert( str.charAt(1000) ); // '' (пустая строка)

// Также можно перебрать строку посимвольно, используя for..of:

for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т. д.)
}

/*

// Строки неизменяемы!

Содержимое строки в JavaScript нельзя изменить. 
Нельзя взять символ посередине и заменить его. 
Как только строка создана — она такая навсегда.

Давайте попробуем так сделать, и убедимся, что это не работает:

*/

let str = 'Hi';

str[0] = 'h'; // ошибка
alert( str[0] ); // не работает

// Можно создать новую строку и записать её в ту же самую переменную вместо старой.

// Например:

let str = 'Hi';

str = 'h' + str[1]; // заменяем строку

alert( str ); // hi

// В последующих разделах мы увидим больше примеров.

// Изменение регистра
// Методы toLowerCase() и toUpperCase() меняют регистр символов:

alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface

// Если мы захотим перевести в нижний регистр какой-то конкретный символ:

alert( 'Interface'[0].toLowerCase() ); // 'i'

/*

// Поиск подстроки
Существует несколько способов поиска подстроки.

str.indexOf
Первый метод — str.indexOf(substr, pos).

Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, 
на которой располагается совпадение, либо -1 при отсутствии совпадений.

Например:

*/

let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру

alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)

/*

Необязательный второй аргумент позволяет начать поиск с определённой позиции.

Например, первое вхождение "id" — на позиции 1. Для того, чтобы найти следующее, начнём поиск с позиции 2:

*/

let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12

// Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. 
// Каждый раз, получив очередную позицию, начинаем новый поиск со следующей:

let str = 'Ослик Иа-Иа посмотрел на виадук';

let target = 'Иа'; // цель поиска

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Найдено тут: ${foundPos}` );
  pos = foundPos + 1; // продолжаем со следующей позиции
}

// Тот же алгоритм можно записать и короче:

let str = "Ослик Иа-Иа посмотрел на виадук";
let target = "Иа";

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}

/*

str.lastIndexOf(substr, position)
Также есть похожий метод str.lastIndexOf(substr, position), который ищет с конца строки к её началу.

Он используется тогда, когда нужно получить самое последнее вхождение: 
перед концом строки или начинающееся до (включительно) определённой позиции.

*/

// При проверке indexOf в условии if есть небольшое неудобство. Такое условие не будет работать:

let str = "Widget with id";

if (str.indexOf("Widget")) {
    alert("Совпадение есть"); // не работает
}

// Мы ищем подстроку "Widget", и она здесь есть, прямо на позиции 0. Но alert не показывается, 
// т. к. str.indexOf("Widget") возвращает 0, и if решает, что тест не пройден.

// Поэтому надо делать проверку на -1:

let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
    alert("Совпадение есть"); // теперь работает
}

/*

Трюк с побитовым НЕ
Существует старый трюк с использованием побитового оператора НЕ — ~. 
Он преобразует число в 32-разрядное целое со знаком (signed 32-bit integer). 
Дробная часть, в случае, если она присутствует, отбрасывается. Затем все биты числа инвертируются.

На практике это означает простую вещь: для 32-разрядных целых чисел значение ~n равно -(n+1).

В частности:

*/

alert( ~2 ); // -3, то же, что -(2+1)
alert( ~1 ); // -2, то же, что -(1+1)
alert( ~0 ); // -1, то же, что -(0+1)
alert( ~-1 ); // 0, то же, что -(-1+1)

/*

Таким образом, ~n равняется 0 только при n == -1 
(для любого n, входящего в 32-разрядные целые числа со знаком).

Соответственно, прохождение проверки if ( ~str.indexOf("…") ) 
означает, что результат indexOf отличен от -1, совпадение есть.

Это иногда применяют, чтобы сделать проверку indexOf компактнее:

*/

let str = "Widget";

if (~str.indexOf("Widget")) { // В случае если str.indexOf('Widget') === 0, в проверке будет -(0+1)
  alert( 'Совпадение есть' ); // работает
}

/*

Обычно использовать возможности языка каким-либо неочевидным образом не рекомендуется, 
но этот трюк широко используется в старом коде, поэтому его важно понимать.

Просто запомните: if (~str.indexOf(…)) означает «если найдено».

Впрочем, если быть точнее, из-за того, что большие числа обрезаются до 32 битов оператором ~, 
существуют другие числа, для которых результат тоже будет 0, самое маленькое из которых — ~4294967295=0. 
Поэтому такая проверка будет правильно работать только для строк меньшей длины.

На данный момент такой трюк можно встретить только в старом коде, 
потому что в новом он просто не нужен: есть метод .includes (см. ниже).

// includes, startsWith, endsWith

Более современный метод str.includes(substr, pos) возвращает true, 
если в строке str есть подстрока substr, либо false, если нет.

Это — правильный выбор, если нам необходимо проверить, есть ли совпадение, но позиция не нужна:

*/

alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false

// Необязательный второй аргумент str.includes позволяет начать поиск с определённой позиции:

alert( "Midget".includes("id") ); // true
alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3

// Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:

alert( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget"
alert( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"

/*

Получение подстроки
В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.

str.slice(start [, end])
Возвращает часть строки от start до (не включая) end.

Например:

*/

let str = "stringify";
// 'strin', символы от 0 до 5 (не включая 5)
alert( str.slice(0, 5) );
// 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
alert( str.slice(0, 1) );

// Если аргумент end отсутствует, slice возвращает символы до конца строки:

let str = "stringify";
alert( str.slice(2) ); // ringify, с позиции 2 и до конца

// Также для start/end можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки:

let str = "stringify";

// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
alert( str.slice(-4, -1) ); // gif

/*

str.substring(start [, end])
Возвращает часть строки между start и end (не включая) end.

Это — почти то же, что и slice, но можно задавать start больше end.
Если start больше end, то метод substring сработает так, как если бы аргументы были поменяны местами.

Например:

*/

let str = "stringify";

// для substring эти два примера — одинаковы
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// …но не для slice:
alert( str.slice(2, 6) ); // "ring" (то же самое)
alert( str.slice(6, 2) ); // "" (пустая строка)

/* Отрицательные значения substring, в отличие от slice, не поддерживает, они интерпретируются как 0. 
str.substr(start [, length])
Возвращает часть строки от start длины length.

В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции:

*/

let str = "stringify";
// ring, получаем 4 символа, начиная с позиции 2
alert( str.substr(2, 4) );

// Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:

let str = "stringify";
// gi, получаем 2 символа, начиная с позиции 4 с конца строки
alert( str.substr(-4, 2) );

// Давайте подытожим, как работают эти методы, чтобы не запутаться:

/*

slice(start, end)	от start до end (не включая end)	можно передавать отрицательные значения
substring(start, end)	между start и end	отрицательные значения равнозначны 0
substr(start, length)	length символов, начиная от start	значение start может быть отрицательным

*/

/*

Какой метод выбрать?
Все эти методы эффективно выполняют задачу. Формально у метода substr есть небольшой недостаток: 
он описан не в собственно спецификации JavaScript, а в приложении к ней — Annex B. 
Это приложение описывает возможности языка для использования в браузерах, существующие в основном по историческим причинам. 
Таким образом, в другом окружении, отличном от браузера, он может не поддерживаться. Однако на практике он работает везде.

Из двух других вариантов, slice более гибок, он поддерживает отрицательные аргументы, и его короче писать. 
Так что, в принципе, можно запомнить только его.

*/

// Сравнение строк

/*

Как мы знаем из главы Операторы сравнения, строки сравниваются посимвольно в алфавитном порядке.

Тем не менее, есть некоторые нюансы.
Строчные буквы больше заглавных:

*/

alert( 'a' > 'Z' ); // true

// Буквы, имеющие диакритические знаки, идут «не по порядку»:

alert( 'Österreich' > 'Zealand' ); // true

/*

Это может привести к своеобразным результатам при сортировке названий стран: нормально было бы ожидать, что Zealand будет после Österreich в списке.

Чтобы разобраться, что происходит, давайте ознакомимся с внутренним представлением строк в JavaScript.
Строки кодируются в UTF-16. Таким образом, у любого символа есть соответствующий код. Есть специальные методы, позволяющие получить символ по его коду и наоборот.

str.codePointAt(pos)
Возвращает код для символа, находящегося на позиции pos:

*/

// одна и та же буква в нижнем и верхнем регистре
// будет иметь разные коды
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90

// String.fromCodePoint(code)
// Создаёт символ по его коду code

alert( String.fromCodePoint(90) ); // Z

// Также можно добавлять Юникодные символы по их кодам, используя \u с шестнадцатеричным кодом символа:

// 90 — 5a в шестнадцатеричной системе счисления
alert( '\u005a' ); // Z

// Давайте сделаем строку, содержащую символы с кодами от 65 до 220 — это латиница и ещё некоторые распространённые символы:

let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ

/*

Как видите, сначала идут заглавные буквы, затем несколько спецсимволов, затем строчные и Ö ближе к концу вывода.
Теперь очевидно, почему a > Z.

Символы сравниваются по их кодам. Больший код — больший символ. Код a (97) больше кода Z (90).

Все строчные буквы идут после заглавных, так как их коды больше.
Некоторые буквы, такие как Ö, вообще находятся вне основного алфавита. 
У этой буквы код больше, чем у любой буквы от a до z.

// Правильное сравнение

«Правильный» алгоритм сравнения строк сложнее, чем может показаться, так как разные языки используют разные алфавиты.

Поэтому браузеру нужно знать, какой язык использовать для сравнения.

К счастью, все современные браузеры (для IE10− нужна дополнительная библиотека Intl.JS) поддерживают стандарт ECMA 402, 
обеспечивающий правильное сравнение строк на разных языках с учётом их правил.

Для этого есть соответствующий метод.

Вызов str.localeCompare(str2) возвращает число, которое показывает, какая строка больше в соответствии с правилами языка:

Отрицательное число, если str меньше str2.
Положительное число, если str больше str2.
0, если строки равны.
Например:

*/

alert( 'Österreich'.localeCompare('Zealand') ); // -1

/*

У этого метода есть два дополнительных аргумента, которые указаны в документации. Первый позволяет указать язык 
(по умолчанию берётся из окружения) — от него зависит порядок букв. Второй — определить дополнительные правила, 
такие как чувствительность к регистру, а также следует ли учитывать различия между "a" и "á".

// Как всё устроено, Юникод

Глубокое погружение в тему
Этот раздел более подробно описывает, как устроены строки. Такие знания пригодятся, если вы намерены работать 
с эмодзи, редкими математическими символами, иероглифами, либо с ещё какими-то редкими символами.

Если вы не планируете их поддерживать, эту секцию можно пропустить.

Суррогатные пары
Многие символы возможно записать одним 16-битным словом: это и буквы большинства европейских языков, и числа, и даже многие иероглифы.

Но 16 битов — это 65536 комбинаций, так что на все символы этого, разумеется, не хватит. Поэтому редкие символы записываются двумя 16-битными словами — это также называется «суррогатная пара».

Длина таких строк — 2:

*/

alert( '𝒳'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X
alert( '😂'.length ); // 2, FACE WITH TEARS OF JOY
alert( '𩷶'.length ); // 2, редкий китайский иероглиф

/*

Обратите внимание, суррогатные пары не существовали, когда был создан JavaScript, поэтому язык не обрабатывает их адекватно!

Ведь в каждой из этих строк только один символ, а length показывает длину 2.

String.fromCodePoint и str.codePointAt — два редких метода, правильно работающие с суррогатными парами, 
но они и появились в языке недавно. До них были только String.fromCharCode и str.charCodeAt. Эти методы, 
вообще, делают то же самое, что fromCodePoint/codePointAt, но не работают с суррогатными парами.

Получить символ, представленный суррогатной парой, может быть не так просто, потому что суррогатная пара интерпретируется как два символа:

*/

alert( '𝒳'[0] ); // странные символы…
alert( '𝒳'[1] ); // …части суррогатной пары

/*

Части суррогатной пары не имеют смысла сами по себе, так что вызовы alert в этом примере покажут лишь мусор.

Технически, суррогатные пары возможно обнаружить по их кодам: если код символа находится в диапазоне 0xd800..0xdbff, 
то это — первая часть суррогатной пары. Следующий символ — вторая часть — имеет код в диапазоне 0xdc00..0xdfff. 
Эти два диапазона выделены исключительно для суррогатных пар по стандарту.

В данном случае:

*/

// charCodeAt не поддерживает суррогатные пары, поэтому возвращает код для их частей

alert( '𝒳'.charCodeAt(0).toString(16) ); // d835, между 0xd800 и 0xdbff
alert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3, между 0xdc00 и 0xdfff

// Дальше в главе Перебираемые объекты будут ещё способы работы с суррогатными парами. 
// Для этого есть и специальные библиотеки, но нет достаточно широко известной, чтобы предложить её здесь.

/*

Диакритические знаки и нормализация
Во многих языках есть символы, состоящие из некоторого основного символа со знаком сверху или снизу.

Например, буква a — это основа для àáâäãåā. Наиболее используемые составные символы имеют свой собственный код в таблице UTF-16. 
Но не все, в силу большого количества комбинаций.

Чтобы поддерживать любые комбинации, UTF-16 позволяет использовать несколько Юникодных символов: 
основной и дальше один или несколько особых символов-знаков.

Например, если после S добавить специальный символ «точка сверху» (код \u0307), отобразится Ṡ.

*/

alert( 'S\u0307' ); // Ṡ

/*

Если надо добавить сверху (или снизу) ещё один знак — без проблем, просто добавляем соответствующий символ.
Например, если добавить символ «точка снизу» (код \u0323), отобразится S с точками сверху и снизу: Ṩ.

Добавляем два символа:

*/

alert( 'S\u0307\u0323' ); // Ṩ

/*

Это даёт большую гибкость, но из-за того, что порядок дополнительных символов может быть различным, 
мы получаем проблему сравнения символов: можно представить по-разному символы, 
которые ничем визуально не отличаются.

Например:

*/

let s1 = 'S\u0307\u0323'; // Ṩ, S + точка сверху + точка снизу
let s2 = 'S\u0323\u0307'; // Ṩ, S + точка снизу + точка сверху

alert( `s1: ${s1}, s2: ${s2}` );

alert( s1 == s2 ); // false, хотя на вид символы одинаковы (?!)

/*

Для решения этой проблемы есть алгоритм «Юникодной нормализации», 
приводящий каждую строку к единому «нормальному» виду.

Его реализует метод str.normalize(). !!!

*/

alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true

// Забавно, но в нашем случае normalize() «схлопывает» последовательность из трёх символов в один: \u1e68 — S с двумя точками.

alert( "S\u0307\u0323".normalize().length ); // 1

alert( "S\u0307\u0323".normalize() == "\u1e68" ); // true

/*

Разумеется, так происходит не всегда. Просто Ṩ — это достаточно часто используемый символ, 
поэтому создатели UTF-16 включили его в основную таблицу и присвоили ему код.

Подробнее о правилах нормализации и составлении символов можно прочитать в дополнении к стандарту Юникод: 
Unicode Normalization Forms. Для большинства практических целей информации из этого раздела достаточно.

// Итого

- Есть три типа кавычек. Строки, использующие обратные кавычки, могут занимать более одной строки в коде и включать выражения ${…}.
- Строки в JavaScript кодируются в UTF-16.
- Есть специальные символы, такие как \n, и можно добавить символ по его Юникодному коду, используя \u….
- Для получения символа используйте [].
- Для получения подстроки используйте slice или substring.
- Для того, чтобы перевести строку в нижний или верхний регистр, используйте toLowerCase/toUpperCase.
- Для поиска подстроки используйте indexOf или includes/startsWith/endsWith, когда надо только проверить, есть ли вхождение.
- Чтобы сравнить строки с учётом правил языка, используйте localeCompare. !!!

Строки также имеют ещё кое-какие полезные методы:

str.trim() — убирает пробелы в начале и конце строки.
str.repeat(n) — повторяет строку n раз.
…и другие, которые вы можете найти в справочнике. 
(https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String)

Также есть методы для поиска и замены с использованием регулярных выражений. 
Но это отдельная большая тема, поэтому ей посвящена отдельная глава учебника Регулярные выражения.
(https://learn.javascript.ru/regular-expressions)

*/

// Задачи

// Сделать первый символ заглавным
// Напишите функцию ucFirst(string), возвращающую строку str с заглавным первым символом. Например:

// ucFirst('вася') == 'Вася';

const ucFirst = string => {
  string = string.split('')
  string[0] = string[0].toUpperCase()
  return string.join('')
}

console.log(ucFirst('вася'))

// Проверка на спам

/* 

Напишите функцию checkSpam(string), возвращающую true, если str содержит 'viagra' или 'XXX', а иначе false.
Функция должна быть нечувствительна к регистру:

checkSpam('buy ViAgRA now') == true
checkSpam('free xxxxx') == true
checkSpam("innocent rabbit") == false */

const checkSpam = string => {
  return string.toLowerCase().includes('viagra') || 
  string.toLowerCase().includes('xxx')
}

console.log(checkSpam('free xxxxx'))

// Усечение строки

/*

Создайте функцию truncate(str, maxlength), которая проверяет длину строки str и, если она превосходит maxlength, 
заменяет конец str на "…", так, чтобы её длина стала равна maxlength.

Результатом функции должна быть та же строка, если усечение 
не требуется, либо, если необходимо, усечённая строка.

Например:

*/

// truncate("Вот, что мне хотелось бы сказать на эту тему:", 20) = "Вот, что мне хотело…"
// truncate("Всем привет!", 20) = "Всем привет!"

const truncate = (string, maxlength) => {

  if (string.length > maxlength) {
    let clipedStr = ''

    for (let i = 0; i < maxlength; i++) {
        clipedStr += string[i]
    }
  
    return clipedStr.trim() + '...'
  } else {
    return string
  }

}

console.log( truncate('Очень интересное предложение, в котором много букв!', 25) ) // Очень интересное предложе...
console.log( truncate('Очень интересное предложение, в котором много букв!', 255) ) // Очень интересное предложение, в котором много букв!
console.log( truncate('Очень интересное предложение, в котором много букв!') ) // Очень интересное предложение, в котором много букв!

// Выделить число

/* 

Есть стоимость в виде строки "$120". То есть сначала идёт знак валюты, а затем – число.
Создайте функцию extractCurrencyValue(str), которая будет из такой строки выделять числовое значение и возвращать его.

Например:

*/

// alert( extractCurrencyValue('$120') === 120 ); // true

const extractCurrencyValue = string => +string.replace(/\D/g, ''); 
// Возвращаем строку, где любые символы, кроме чисел, удаляются

console.log(extractCurrencyValue('$$1220$$'))

/*

// Массивы

Объекты позволяют хранить данные со строковыми ключами. Это замечательно.

Но довольно часто мы понимаем, что нам необходима упорядоченная коллекция данных, в которой присутствуют 1-й, 2-й, 3-й элементы и т.д. 
Например, она понадобится нам для хранения списка чего-либо: пользователей, товаров, элементов HTML и т.д.

В этом случае использовать объект неудобно, так как он не предоставляет методов управления порядком элементов. 
Мы не можем вставить новое свойство «между» уже существующими. Объекты просто не предназначены для этих целей.

Для хранения упорядоченных коллекций существует особая структура данных, которая называется массив, Array.

// Объявление

Существует два варианта синтаксиса для создания пустого массива:

*/

let arr = new Array();
let arr = [];

// Практически всегда используется второй вариант синтаксиса. В скобках мы можем указать начальные значения элементов:

let fruits = ["Яблоко", "Апельсин", "Слива"];

// Элементы массива нумеруются, начиная с нуля.
// Мы можем получить элемент, указав его номер в квадратных скобках:

let fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits[0] ); // Яблоко
alert( fruits[1] ); // Апельсин
alert( fruits[2] ); // Слива

// Мы можем заменить элемент:

fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]

// …Или добавить новый к существующему массиву:

fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]

// Общее число элементов массива содержится в его свойстве length:

let fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits.length ); // 3

// Вывести массив целиком можно при помощи alert.

let fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits ); // Яблоко, Апельсин, Слива

// В массиве могут храниться элементы любого типа.
// Например:

// разные типы значений
let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];

// получить элемент с индексом 1 (объект) и затем показать его свойство
alert( arr[1].name ); // Джон

// получить элемент с индексом 3 (функция) и выполнить её
arr[3](); // привет

/*

Висячая запятая
Список элементов массива, как и список свойств объекта, может оканчиваться запятой:

*/

let fruits = [
  "Яблоко",
  "Апельсин",
  "Слива",
];

// «Висячая запятая» упрощает процесс добавления/удаления элементов, так как все строки становятся идентичными.

// Получение последних элементов при помощи «at»

// Новая возможность
// Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться полифил.

/*

Допустим, нам нужен последний элемент массива.

Некоторые языки программирования позволяют использовать отрицательные индексы для той же цели, как-то так: fruits[-1].
Однако, в JavaScript такая запись не сработает. Её результатом будет undefined, поскольку индекс в квадратных скобках понимается буквально.

Мы можем явно вычислить индекс последнего элемента, а затем получить к нему доступ вот так: fruits[fruits.length - 1].

*/

let fruits = ["Apple", "Orange", "Plum"];
alert( fruits[fruits.length-1] ); // Plum

// Немного громоздко, не так ли? Нам нужно дважды написать имя переменной.
// К счастью, есть более короткий синтаксис: fruits.at (-1):

let fruits = ["Apple", "Orange", "Plum"];
// то же самое, что и fruits[fruits.length-1]
alert( fruits.at(-1) ); // Plum

/* 

Другими словами, arr.at(i):

это ровно то же самое, что и arr[i], если i >= 0.
для отрицательных значений i, он отступает от конца массива.

Методы pop/push, shift/unshift
Очередь – один из самых распространённых вариантов применения массива. В области компьютерных 
наук так называется упорядоченная коллекция элементов, поддерживающая два вида операций:

- push добавляет элемент в конец.
- shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.

Массивы поддерживают обе операции.

На практике необходимость в этом возникает очень часто. Например, очередь сообщений, которые надо показать на экране.

Существует и другой вариант применения для массивов – структура данных, называемая стек.

Она поддерживает два вида операций:

push добавляет элемент в конец.
pop удаляет последний элемент.
Таким образом, новые элементы всегда добавляются или удаляются из «конца».

Примером стека обычно служит колода карт: новые карты кладутся наверх и берутся тоже сверху:

Массивы в JavaScript могут работать и как очередь, и как стек. Мы можем добавлять/удалять элементы как в начало, так и в конец массива.
В компьютерных науках структура данных, делающая это возможным, называется двусторонняя очередь.

*/

// Методы, работающие с концом массива:

// pop
// Удаляет последний элемент из массива и возвращает его:

let fruits = ["Яблоко", "Апельсин", "Груша"];

alert( fruits.pop() ); // удаляем "Груша" и выводим его

alert( fruits ); // Яблоко, Апельсин

// И fruits.pop() и fruits.at(-1) возвращают последний элемент массива, но fruits.pop() также изменяет массив, удаляя его.

// push
// Добавляет элемент в конец массива:

let fruits = ["Яблоко", "Апельсин"];

fruits.push("Груша");

alert( fruits ); // Яблоко, Апельсин, Груша

/*

Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....
Методы, работающие с началом массива:

*/

// shift
// Удаляет из массива первый элемент и возвращает его:

let fruits = ["Яблоко", "Апельсин", "Груша"];

alert( fruits.shift() ); // удаляем Яблоко и выводим его

alert( fruits ); // Апельсин, Груша

// unshift
// Добавляет элемент в начало массива:

let fruits = ["Апельсин", "Груша"];

fruits.unshift('Яблоко');

alert( fruits ); // Яблоко, Апельсин, Груша

// Методы push и unshift могут добавлять сразу несколько элементов:

let fruits = ["Яблоко"];

fruits.push("Апельсин", "Груша");
fruits.unshift("Ананас", "Лимон");

// ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
alert( fruits );

// Внутреннее устройство массива

/*

Массив – это особый подвид объектов. Квадратные скобки, используемые для того, чтобы получить доступ к свойству arr[0] – это 
по сути обычный синтаксис доступа по ключу, как obj[key], где в роли obj у нас arr, а в качестве ключа – числовой индекс.

Массивы расширяют объекты, так как предусматривают специальные методы для работы с упорядоченными 
коллекциями данных, а также свойство length. Но в основе всё равно лежит объект.

Следует помнить, что в JavaScript существует 8 основных типов данных. 
Массив является объектом и, следовательно, ведёт себя как объект.

Например, копируется по ссылке:

*/

let fruits = ["Банан"]

let arr = fruits; // копируется по ссылке (две переменные ссылаются на один и тот же массив)

alert( arr === fruits ); // true

arr.push("Груша"); // массив меняется по ссылке

alert( fruits ); // Банан, Груша - теперь два элемента

/*

…Но то, что действительно делает массивы особенными – это их внутреннее представление. 
Движок JavaScript старается хранить элементы массива в непрерывной области памяти, один 
за другим, так, как это показано на иллюстрациях к этой главе. Существуют и другие способы оптимизации, 
благодаря которым массивы работают очень быстро.

Но все они утратят эффективность, если мы перестанем работать с массивом как 
с «упорядоченной коллекцией данных» и начнём использовать его как обычный объект.

Например, технически мы можем сделать следующее:

*/

let fruits = []; // создаём массив

fruits[99999] = 5; // создаём свойство с индексом, намного превышающим длину массива

fruits.age = 25; // создаём свойство с произвольным именем

/*

Это возможно, потому что в основе массива лежит объект. Мы можем присвоить ему любые свойства.

Но движок поймёт, что мы работаем с массивом, как с обычным объектом. Способы оптимизации, используемые для массивов, 
в этом случае не подходят, поэтому они будут отключены и никакой выгоды не принесут.

Варианты неправильного применения массива:

Добавление нечислового свойства, например: arr.test = 5.
Создание «дыр», например: добавление arr[0], затем arr[1000] (между ними ничего нет).
Заполнение массива в обратном порядке, например: arr[1000], arr[999] и т.д.
Массив следует считать особой структурой, позволяющей работать с упорядоченными данными. Для этого массивы предоставляют специальные методы. 
Массивы тщательно настроены в движках JavaScript для работы с однотипными упорядоченными данными, поэтому, пожалуйста, используйте их именно 
в таких случаях. Если вам нужны произвольные ключи, вполне возможно, лучше подойдёт обычный объект {}.

// Эффективность

Методы push/pop выполняются быстро, а методы shift/unshift – медленно.

Почему работать с концом массива быстрее, чем с его началом? Давайте посмотрим, что происходит во время выполнения:

*/

fruits.shift(); // удаляем первый элемент с начала

/*

Просто взять и удалить элемент с номером 0 недостаточно. Нужно также заново пронумеровать остальные элементы.

Операция shift должна выполнить 3 действия:

- Удалить элемент с индексом 0.
- Сдвинуть все элементы влево, заново пронумеровать их, заменив 1 на 0, 2 на 1 и т.д.
- Обновить свойство length .

// Чем больше элементов содержит массив, тем больше времени потребуется для того, чтобы их переместить, больше операций с памятью.

То же самое происходит с unshift: чтобы добавить элемент в начало массива, нам нужно сначала сдвинуть существующие элементы вправо, увеличивая их индексы.

А что же с push/pop? Им не нужно ничего перемещать. Чтобы удалить элемент в конце массива, метод pop очищает индекс и уменьшает значение length.
Действия при операции pop:

*/

fruits.pop(); // удаляем один элемент с конца

/*

Метод pop не требует перемещения, потому что остальные элементы остаются с теми же индексами. 
Именно поэтому он выполняется очень быстро.

Аналогично работает метод push.

// Перебор элементов

Одним из самых старых способов перебора элементов массива является цикл for по цифровым индексам:

*/

let arr = ["Яблоко", "Апельсин", "Груша"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}

// Но для массивов возможен и другой вариант цикла, for..of:

let fruits = ["Яблоко", "Апельсин", "Слива"];

// проходит по значениям
for (let fruit of fruits) {
  alert( fruit );
}

// Цикл for..of не предоставляет доступа к номеру текущего элемента, только к его значению, 
// но в большинстве случаев этого достаточно. А также это короче.

// Технически, так как массив является объектом, можно использовать и вариант for..in:

let arr = ["Яблоко", "Апельсин", "Груша"];

for (let key in arr) {
  alert( arr[key] ); // Яблоко, Апельсин, Груша
}

/*

Но на самом деле это – плохая идея. Существуют скрытые недостатки этого способа:

Цикл for..in выполняет перебор всех свойств объекта, а не только цифровых.

В браузере и других программных средах также существуют так называемые «псевдомассивы» – объекты, которые выглядят, 
как массив. То есть, у них есть свойство length и индексы, но они также могут иметь дополнительные нечисловые свойства 
и методы, которые нам обычно не нужны. Тем не менее, цикл for..in выведет и их. Поэтому, если нам приходится иметь дело 
с объектами, похожими на массив, такие «лишние» свойства могут стать проблемой.

Цикл for..in оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее. 
Увеличение скорости выполнения может иметь значение только при возникновении узких мест. 
Но мы всё же должны представлять разницу.

В общем, не следует использовать цикл for..in для массивов.

// Немного о «length»
Свойство length автоматически обновляется при изменении массива. Если быть точными, это не количество элементов массива, а наибольший цифровой индекс плюс один.

Например, единственный элемент, имеющий большой индекс, даёт большую длину:

*/

let fruits = [];
fruits[123] = "Яблоко";

alert( fruits.length ); // 124

/* 

Обратите внимание, что обычно мы не используем массивы таким образом.

Ещё один интересный факт о свойстве length – его можно перезаписать.

Если мы вручную увеличим его, ничего интересного не произойдёт. 
Зато, если мы уменьшим его, массив станет короче. 
Этот процесс необратим, как мы можем понять из примера:

*/

let arr = [1, 2, 3, 4, 5];

arr.length = 2; // укорачиваем до двух элементов
alert( arr ); // [1, 2]

arr.length = 5; // возвращаем length как было
alert( arr[3] ); // undefined: значения не восстановились

// Таким образом, самый простой способ очистить массив – это arr.length = 0;

// new Array()
// Существует ещё один вариант синтаксиса для создания массива:

let arr = new Array("Яблоко", "Груша", "и тд");

/*

Он редко применяется, так как квадратные скобки [] короче. Кроме того, у него есть хитрая особенность.

Если new Array вызывается с одним аргументом, который представляет собой число, он создаёт массив без элементов, но с заданной длиной.
Давайте посмотрим, как можно оказать себе медвежью услугу:

*/

let arr = new Array(2); // создастся ли массив [2]?

alert( arr[0] ); // undefined! нет элементов.

alert( arr.length ); // length 2

/*

Как мы видим, в коде, представленном выше, в new Array(number) все элементы равны undefined.

Чтобы избежать появления таких неожиданных ситуаций, мы обычно используем квадратные 
скобки, если, конечно, не знаем точно, что по какой-то причине нужен именно Array.

// Многомерные массивы

Массивы могут содержать элементы, которые тоже являются массивами. 
Это можно использовать для создания многомерных массивов, например, для хранения матриц: !!!

*/

let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5, центральный элемент

/* 

toString
Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми.

Например:

*/

let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true

// Давайте теперь попробуем следующее:

alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"

/*

Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, они реализуют только преобразование toString, 
таким образом, здесь [] становится пустой строкой, [1] становится "1", а [1,2] становится "1,2".

Когда бинарный оператор плюс "+" добавляет что-либо к строке, он тоже преобразует это в строку, таким образом:

*/

alert( "" + 1 ); // "1"
alert( "1" + 1 ); // "11"
alert( "1,2" + 1 ); // "1,21"

/*

// ИТОГО
Массив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.

Объявление:

*/

// квадратные скобки (обычно)
let arr = [item1, item2...];

// new Array (очень редко)
let arr = new Array(item1, item2...);

/*

Вызов new Array(number) создаёт массив с заданной длиной, но без элементов.

Свойство length отражает длину массива или, если точнее, его последний цифровой индекс плюс один. 
Длина корректируется автоматически методами массива.

Если мы уменьшаем length вручную, массив укорачивается.

Мы можем использовать массив как двустороннюю очередь, используя следующие операции:

push(...items)добавляет items в конец массива.
pop() удаляет элемент в конце массива и возвращает его.
shift() удаляет элемент в начале массива и возвращает его.
unshift(...items) добавляет items в начало массива.
Чтобы пройтись по элементам массива:

for (let i=0; i<arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.
for (let item of arr) – современный синтаксис только для значений элементов (к индексам нет доступа).
for (let i in arr) – никогда не используйте для массивов!

Мы вернёмся к массивам и изучим другие методы добавления, удаления, выделения элементов и сортировки массивов в главе: Методы массивов.

*/

// Задачи

// Скопирован ли массив?
// Что выведет следующий код

let fruits = ["Яблоки", "Груша", "Апельсин"];

// добавляем новое значение в "копию"
let shoppingCart = fruits;
shoppingCart.push("Банан");

// что в fruits?
alert( fruits.length ); // 4!

// Массивы являются видом одъектов, соответственно они тоже работают по ссылкам

// Ответ: 4

/*

let fruits = ["Яблоки", "Груша", "Апельсин"];
let shoppingCart = fruits;
shoppingCart.push("Банан");
alert( fruits.length ); // 4

Потому, что массивы – это объекты. Обе переменные shoppingCart и fruits являются ссылками на один и тот же массив.

*/

// Операции с массивами

/*

Давайте произведём 5 операций с массивом.

Создайте массив styles с элементами «Джаз» и «Блюз».
Добавьте «Рок-н-ролл» в конец.
Замените значение в середине на «Классика». Ваш код для поиска значения в середине должен работать для массивов с любой длиной.
Удалите первый элемент массива и покажите его.
Вставьте Рэп и Регги в начало массива.
Массив по ходу выполнения операций:

*/

const styles = ['Джаз', 'Блюз']
styles.push('Рок-н-ролл')
styles[(styles.length - 1) / 2] = 'Классика'
console.log(styles.shift())
styles.unshift('Рэп', 'Регги')

console.log(styles)

// Вызов в контексте массива
// Каков результат? Почему?

let arr = ["a", "b"];

arr.push(function() {
  alert( this );
});

arr[2](); // ?

/*

Вызов arr[2]() синтаксически – старый добрый obj[method](), в роли obj – arr, а в роли method – 2.

Итак, у нас есть вызов функции arr[2] как метода объекта. Соответственно, он получает в качестве this объект arr и выводит массив:

*/

let arr = ["a", "b"];

arr.push(function() {
  alert( this );
})

arr[2](); // "a","b",function

// this = arr

/*

// Сумма введённых чисел

Напишите функцию sumInput(), которая:

Просит пользователя ввести значения, используя prompt и сохраняет их в массив.
Заканчивает запрашивать значения, когда пользователь введёт не числовое значение, пустую строку или нажмёт «Отмена».
Подсчитывает и возвращает сумму элементов массива.
P.S. Ноль 0 – считается числом, не останавливайте ввод значений при вводе «0».

*/

// const sumInput = () => {
//   let numbersArray = []

//   for (let i = 0; enteredNumber != null; i++) {
//     let enteredNumber = prompt('Введите число', '')
//     numbersArray.push(enteredNumber)
//     console.log(numbersArray, numbersArray[i])
//   }

// }

function sumInput() {

  let numbers = [];

  while (true) {

    let value = prompt("Введите число", 0);

    if (value === "" || value === null || !isFinite(value)) break;

    numbers.push(+value);
  }

  let sum = 0;
  for (let number of numbers) {
    sum += number;
  }
  return sum;
}

alert( sumInput() );